<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1_5-存算一体经典文章精读</title>
    <link href="/2024/08/26/1-5-%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93%E7%BB%8F%E5%85%B8%E6%96%87%E7%AB%A0%E7%B2%BE%E8%AF%BB/"/>
    <url>/2024/08/26/1-5-%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93%E7%BB%8F%E5%85%B8%E6%96%87%E7%AB%A0%E7%B2%BE%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-PRIME-A-Novel-Processing-in-memory-Architecture-for-Neural-Network-Computation-in-ReRAM-based-Main-Memory"><a href="#1-PRIME-A-Novel-Processing-in-memory-Architecture-for-Neural-Network-Computation-in-ReRAM-based-Main-Memory" class="headerlink" title="1. PRIME: A Novel Processing-in-memory Architecture for Neural Network Computation in ReRAM-based Main Memory"></a>1. PRIME: A Novel Processing-in-memory Architecture for Neural Network Computation in ReRAM-based Main Memory</h1><blockquote><p>团队：清华大学谢源</p></blockquote><h2 id="1-1-摘要"><a href="#1-1-摘要" class="headerlink" title="1.1. 摘要"></a>1.1. 摘要</h2><p>PIM能够很好地解决<strong>内存墙</strong>的问题，ReRAM作为元器件，ReRAM凭借其<code>crossbar array structure</code>，在存算一体方面拥有很强的前景。本文提出了一种架构级别的创新：使得Memory具有计算功能。文章提出的新型存算融合架构叫做<strong>PRIME</strong>，不仅提供了微架构和电路设计，并且提供了软硬件接口来实现各种NN。性能提升有2000多倍，能耗比提升有800多倍(本人对于测量方法存疑)</p><h2 id="1-2-Intro"><a href="#1-2-Intro" class="headerlink" title="1.2. Intro"></a>1.2. Intro</h2><p>传统的电脑采用计算和存储分离架构，CPU和GPU作为计算单元，Memory、Flash、Disks作为存储介质。随着AI的发展，内存墙的问题越来越严重。例如CPU和内存之间的IO的耗能比执行浮点操作高两个数量级。</p><h1 id="2-A-Survey-of-ReRAM-Based-Architectures-for-Processing-In-Memory-and-Neural-Networks"><a href="#2-A-Survey-of-ReRAM-Based-Architectures-for-Processing-In-Memory-and-Neural-Networks" class="headerlink" title="2. A Survey of ReRAM-Based Architectures for Processing-In-Memory and Neural Networks"></a>2. A Survey of ReRAM-Based Architectures for Processing-In-Memory and Neural Networks</h1><ol><li>A Survey of ReRAM-Based Architectures for Processing-In-Memory and Neural Networks</li></ol><blockquote><p>词条1：<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%AE%8A%E9%9B%BB%E9%98%BB%E5%BC%8F%E8%A8%98%E6%86%B6%E9%AB%94">ReRAM</a>,它的优势是：高密度低能量存储以及存内计算&#x2F;搜索引擎。</p></blockquote><p>在这篇文章中主要介绍基于ReRAM的PIM和NN架构。</p><p>ReRAM可以支持模拟矩阵向量乘法，并且可以在内存中进行位操作和查询。在CNN上加速极快，在MLP、transformer、自注意力等都在探索。</p><p>ReRAM有写入限制、对工艺要求高、会发生电阻漂移，同时模拟操作会导致有面积开销，写入能量和延迟都很高，频繁更新权重和大量数据会很难。</p><p>机器学习有两个模块：train和test。<br>神经网络分为ANN和SNN，实际上SNN更能模仿大脑的操作。</p><p>过程变异是指参数与其标称值的偏差。<br>A hard default指的是电阻由于到达写入极限，卡在0或者1.<br>电阻漂移指的是电阻会随着时间产生误差。</p><p>Sneak-paths指的是不是预定期望的电阻路径。</p><p><img src="/%E5%BF%86%E9%98%BB%E5%99%A8%E7%9A%84%E9%A2%84%E8%A8%80.png" srcset="/img/loading.gif" lazyload alt="忆阻器的预言"></p><p>忆阻器是模拟计算，精度会有问题<br>期间本身精度问题</p><p>吴华强团队，唐建石</p>]]></content>
    
    
    <categories>
      
      <category>论文系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存算一体 精读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3_3-Beamer学习记录</title>
    <link href="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Latex和Beamer介绍"><a href="#Latex和Beamer介绍" class="headerlink" title="Latex和Beamer介绍"></a>Latex和Beamer介绍</h1><p>Latex在学术界被广泛使用，常被用作期刊和论文的排版引擎。它的排版能力非常强，并且并不需要很强大的编程基础。</p><p>同样，我们在做学术汇报的时候，很多时候PPT都需要花费大量的时间排版，Beamer可以很好的帮我们解决这个烦恼。在overleaf中有很多现成的beamer-template，大家可以在overleaf搜索，或者直接在github中搜索也可以。</p><p>Overleaf可以帮助我们很好地解决配置latex环境的问题，本文我们就学习一下如何使用beamer来制作Slides。</p><h2 id="1-Latex基础语法"><a href="#1-Latex基础语法" class="headerlink" title="1. Latex基础语法"></a>1. Latex基础语法</h2><h3 id="1-1-Latex源文件基本结构"><a href="#1-1-Latex源文件基本结构" class="headerlink" title="1.1. Latex源文件基本结构"></a>1.1. Latex源文件基本结构</h3><p>Latex主要由两个板块组成：<code>导言区</code>+<code>正文区</code></p><p>一个完整的.tex文件一般长这样：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-comment">%% 导言区</span><br><span class="hljs-keyword">\documentclass</span>&#123;beamer&#125;<br>...<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br><span class="hljs-keyword">\author</span>[]()<br><span class="hljs-keyword">\title</span>&#123;&#125;<br>...<br><br><span class="hljs-comment">%% 正文区</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>...<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br><br></code></pre></td></tr></table></figure><p>导言区用于全局设置，包括导入的包、标题、作者等等，正文区用于正式的论文书写。在一般的学术会议latex模板中，都会提供对应的论文格式，我们直接使用即可。</p><h3 id="1-2-Latex公式排版"><a href="#1-2-Latex公式排版" class="headerlink" title="1.2. Latex公式排版"></a>1.2. Latex公式排版</h3><p>在正文区中，<code>$xxx$</code>来输出数学公式，单个$表示行内公式，两个$$会另起一行显示。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tex"><br><span class="hljs-comment">% test</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\title</span>&#123;This is a test&#125;<br><span class="hljs-keyword">\author</span>&#123;xyw&#125;<br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125;<br><br><span class="hljs-comment">% main</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>    <span class="hljs-keyword">\maketitle</span><br>    Hello world!<br><br>    Lef <span class="hljs-built_in">$</span>f(x<span class="hljs-built_in">$</span> be defined by formula:<br>    <span class="hljs-comment">%here is my big formula</span><br>    <span class="hljs-built_in">$</span><span class="hljs-built_in">$</span>f(x)=3x<span class="hljs-built_in">^</span>2+x-1<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> which is a polynomial of degree 2.<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>显示效果如下：<br><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%85%AC%E5%BC%8F%E6%98%BE%E7%A4%BA%E6%95%88%E6%9E%9C%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="公式显示效果图"></p><h3 id="1-2-Latex中的中文处理方法"><a href="#1-2-Latex中的中文处理方法" class="headerlink" title="1.2. Latex中的中文处理方法"></a>1.2. Latex中的中文处理方法</h3><p>可以导入一个中文宏的包</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125;  <span class="hljs-comment">% 中文宏包</span><br></code></pre></td></tr></table></figure><p>一个完整的示例如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125;<br><br><span class="hljs-keyword">\title</span>&#123;<span class="hljs-keyword">\heiti</span> 杂谈勾股定理&#125;<br><span class="hljs-keyword">\author</span>&#123;<span class="hljs-keyword">\kaishu</span> 张三&#125;<br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125;<br><br><span class="hljs-comment">% 正文区</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>    <span class="hljs-keyword">\maketitle</span><br>    勾股定理可以用现代语言描述如下：<br>    <br>    直角三角形斜边的平方等于两条直角边的平方和。<br><br>    可以用符号语言表述为：设直角三角形<span class="hljs-built_in">$</span>ABC<span class="hljs-built_in">$</span>,其中<br>    <span class="hljs-built_in">$</span><span class="hljs-keyword">\angle</span> C = 90<span class="hljs-built_in">^</span><span class="hljs-keyword">\circ</span><span class="hljs-built_in">$</span><br>    则有：<br>    <span class="hljs-comment">%equation命令用于产生带编号的行间公式：</span><br>    <span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>        AB<span class="hljs-built_in">^</span>2 = BC<span class="hljs-built_in">^</span>2 + AB<span class="hljs-built_in">^</span>2<br>    <span class="hljs-keyword">\end</span>&#123;equation&#125;<span class="hljs-keyword">\label</span>&#123;key&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E4%B8%AD%E6%96%87%E4%BD%BF%E7%94%A8%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA.png" srcset="/img/loading.gif" lazyload alt="中文使用页面展示"></p><p>设置字体可以使用类似于：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\rmfamily</span>&#123;罗马字体族&#125;<br><span class="hljs-keyword">\ttfamily</span>&#123;打字机字体族&#125;<br><span class="hljs-keyword">\heiti</span>&#123;黑体&#125;<br></code></pre></td></tr></table></figure><p>等等来设置字体，包括可以设置字体的粗细</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\textmd</span>&#123;Medium Series&#125;<br><span class="hljs-keyword">\textbf</span>&#123;Boldface Series&#125;<br>&#123;<span class="hljs-keyword">\mdseries</span> Medium Series&#125;<br>&#123;<span class="hljs-keyword">\bfsearisc</span> Boldface Series&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%AD%97%E4%BD%93%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="字体图"></p><p>设置字体的形状:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tex">&#123;<span class="hljs-keyword">\upshape</span> Upright shape&#125;<br>&#123;<span class="hljs-keyword">\itshape</span> Italic Shape&#125;<br>&#123;<span class="hljs-keyword">\slshape</span> Slanted Shape&#125;<br>&#123;<span class="hljs-keyword">\scshape</span> Small Caps Shape&#125;<br>&#123;<span class="hljs-keyword">\songti</span> 宋体&#125;<br>&#123;<span class="hljs-keyword">\heiti</span> 黑体&#125;<br>&#123;<span class="hljs-keyword">\fangsong</span> 仿宋&#125;<br>&#123;<span class="hljs-keyword">\kaishu</span> 楷书&#125;<br><span class="hljs-keyword">\textbf</span>&#123;abd&#125;    <span class="hljs-comment">% 粗体    </span><br><span class="hljs-keyword">\textit</span>&#123;abc&#125;    <span class="hljs-comment">% 斜体</span><br></code></pre></td></tr></table></figure><p><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%AD%97%E4%BD%93%E5%BD%A2%E7%8A%B6.png" srcset="/img/loading.gif" lazyload alt="字体形状"></p><p>Latex的思想是格式和内容分离，因此不建议在文档中使用大量的命令，而是用<code>newcommand</code>定义新的命令来执行相关的操作。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\newcommand</span>&#123;<span class="hljs-keyword">\myfont</span>&#125;&#123;<span class="hljs-keyword">\textit</span>&#123;<span class="hljs-keyword">\textbf</span>&#123;<span class="hljs-keyword">\textsf</span>&#123;Fancy Text&#125;&#125;&#125;&#125;<br><span class="hljs-keyword">\myfont</span><br></code></pre></td></tr></table></figure><p>当需要修改字体时，只需要修改已经定义的命令即可。</p><p>更多和字体有关的资料大家可以<a href="https://cn.overleaf.com/learn/latex/Font_typefaces">RTFM</a></p><h3 id="1-3-Latex文档结构"><a href="#1-3-Latex文档结构" class="headerlink" title="1.3. Latex文档结构"></a>1.3. Latex文档结构</h3><p>latex主要有<code>section</code>, <code>subsection</code>, <code>subsubsection</code>来构建提纲。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\section</span>&#123;引言&#125;<br>    This is a Introduction. <br><span class="hljs-keyword">\section</span>&#123;实验方法&#125;<br><span class="hljs-keyword">\section</span>&#123;实验结果&#125;<br><span class="hljs-keyword">\subsection</span>&#123;结果1&#125;<br><span class="hljs-keyword">\subsection</span>&#123;结果2&#125;<br><span class="hljs-keyword">\subsection</span>&#123;结果3&#125;<br><span class="hljs-keyword">\subsubsection</span>&#123;分析1&#125;<br><span class="hljs-keyword">\subsubsection</span>&#123;分析2&#125;<br><span class="hljs-keyword">\section</span>&#123;附录&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Latex%E6%96%87%E6%A1%A3%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="Latex文档结构"></p><p>在文章段落中，使用<code>\\</code>换行，不会产生新的段落，即没有首行缩进；使用<code>\par</code>，则会产生新的段落。</p><p><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E6%AE%B5%E8%90%BD%E6%8D%A2%E8%A1%8C%E6%B5%8B%E8%AF%95.png" srcset="/img/loading.gif" lazyload alt="段落换行测试"></p><p>使用<code>\tableofcontents</code>会产生文档目录<br><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E7%9B%AE%E5%BD%95%E5%B1%95%E7%A4%BA.png" srcset="/img/loading.gif" lazyload alt="目录展示"></p><h3 id="1-4-插图"><a href="#1-4-插图" class="headerlink" title="1.4. 插图"></a>1.4. 插图</h3><p>主要格式如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-comment">% 导言区：\usepackage&#123;graphicx&#125;</span><br><br><span class="hljs-comment">% 语法：\includegraphics[&lt;选项&gt;]&#123;&lt;文件名&gt;&#125;</span><br><span class="hljs-comment">% 格式：EPS PDF PNG JPEG BMP</span><br><span class="hljs-comment">% &lt;选项&gt;：scale(缩放因子)、height(固定值的图像高度)、width(固定值的图像宽度)、height=0.1\textheight(版型0.1倍的图像高度、width=0.2\textwidth(版型0.2倍的图像宽度)、angle=-45(旋转角度)， 可以同时指定多个可选参数，不同参数之间用逗号间隔)</span><br></code></pre></td></tr></table></figure><p>一个具体的实例如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125;<br><br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br><span class="hljs-keyword">\graphicspath</span>&#123;&#123;figures/&#125;,&#123;pics/&#125;&#125; <span class="hljs-comment">%图片在当前目录下的figures目录</span><br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\LaTeX</span>&#123;&#125;中的插图<br><span class="hljs-keyword">\includegraphics</span>[scale=0.3]&#123;figures/image.png&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-5-表格"><a href="#1-5-表格" class="headerlink" title="1.5. 表格"></a>1.5. 表格</h3><p><strong>概要</strong>：使用<code>tabular</code>生成表格，该环境需要指定一个排版格式的必选参数：<code>l, c, r, p</code></p><ul><li>l：左对齐</li><li>c：居中</li><li>r：右对齐</li><li>p：内容超过宽度时自动换行</li></ul><p>语法如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;tabular&#125;[&lt;垂直对齐方式&gt;]&#123;&lt;列格式说明&gt;&#125;<br>&lt;表项&gt; <span class="hljs-built_in">&amp;</span> &lt;表项&gt; <span class="hljs-built_in">&amp;</span> &lt;表项&gt; <span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><br><span class="hljs-comment">% \\ 表示换行</span><br><br></code></pre></td></tr></table></figure><p>完整的示例如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;ctexart&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;| l || c | c | c | r&#125; <span class="hljs-comment">% 用 | 产生竖线，两个|可以产生双竖线，列格式说明中空格不起作用</span><br><span class="hljs-keyword">\hline</span> <span class="hljs-comment">%产生表格横线</span><br>A组 <span class="hljs-built_in">&amp;</span> 队名 <span class="hljs-built_in">&amp;</span> 比分 <span class="hljs-built_in">&amp;</span> 备注<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><span class="hljs-keyword">\hline</span> <span class="hljs-comment">%产生双横线</span><br>1st <span class="hljs-built_in">&amp;</span> RNG <span class="hljs-built_in">&amp;</span> 6-0 <span class="hljs-built_in">&amp;</span> 出线<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br>2nd <span class="hljs-built_in">&amp;</span> DK <span class="hljs-built_in">&amp;</span> 3-3 <span class="hljs-built_in">&amp;</span> 出线<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br>3rd <span class="hljs-built_in">&amp;</span> T1 <span class="hljs-built_in">&amp;</span> 2-4 <span class="hljs-built_in">&amp;</span> 淘汰<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br>4th <span class="hljs-built_in">&amp;</span> G2 <span class="hljs-built_in">&amp;</span> 1-5 <span class="hljs-built_in">&amp;</span> 淘汰<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E8%A1%A8%E6%A0%BC%E7%A4%BA%E4%BE%8B.png" srcset="/img/loading.gif" lazyload alt="表格示例"></p><h3 id="1-6-浮动体"><a href="#1-6-浮动体" class="headerlink" title="1.6. 浮动体"></a>1.6. 浮动体</h3><p>功能：</p><blockquote><ol><li><strong>实现灵活分页</strong>，防止因为无法分割的内容产生页面留白</li><li><strong>给图标添加标题</strong></li><li><strong>交叉引用</strong></li></ol></blockquote><p>以下是figure&#x2F;table的环境</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;figure&#125;[&lt;允许位置&gt;]<br>    &lt;任意内容&gt;<br><span class="hljs-keyword">\end</span>&#123;figure&#125;<br></code></pre></td></tr></table></figure><ul><li>h: here, 代码所在的上下文位置</li><li>t：top，代码所在的页面，或者之后页面的顶部</li><li>b：bottom，代码所在的页面，或者之后页面的底部</li><li>p：page，浮动页面</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;ctexart&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br><span class="hljs-keyword">\graphicspath</span>&#123;&#123;figures/&#125;&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%figure浮动体环境</span><br><span class="hljs-keyword">\LaTeX</span>&#123;&#125;中的插图：<span class="hljs-keyword">\ref</span>&#123;fig-p1&#125; <span class="hljs-comment">%ref引用标签</span><br> <br><span class="hljs-keyword">\begin</span>&#123;figure&#125;[htbp] <span class="hljs-comment">%通过可选参数指定浮动体的排版位置</span><br><span class="hljs-keyword">\centering</span> <span class="hljs-comment">%让环境中的内容居中</span><br><span class="hljs-keyword">\includegraphics</span>[scale=0.3]&#123;figures/image.png&#125;<br><span class="hljs-keyword">\caption</span>&#123;<span class="hljs-keyword">\TeX</span> 浮动体学习&#125;<span class="hljs-keyword">\label</span>&#123;fig-p1&#125; <span class="hljs-comment">%caption设置标题,lable为浮动体设置标签</span><br><span class="hljs-keyword">\end</span>&#123;figure&#125;<br><br><span class="hljs-comment">%table浮动体环境</span><br><span class="hljs-keyword">\LaTeX</span>&#123;&#125;中的表格<span class="hljs-keyword">\ref</span>&#123;table-score&#125;<br><span class="hljs-keyword">\begin</span>&#123;table&#125;[h]<br><span class="hljs-keyword">\centering</span><br><span class="hljs-keyword">\caption</span>&#123;积分情况&#125;<span class="hljs-keyword">\label</span>&#123;table-score&#125;<br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;| l || c | c | c | r&#125; <span class="hljs-comment">% 用 | 产生竖线，两个|可以产生双竖线，列格式说明中空格不起作用</span><br><span class="hljs-keyword">\hline</span> <span class="hljs-comment">%产生表格横线</span><br>A组 <span class="hljs-built_in">&amp;</span> 队名 <span class="hljs-built_in">&amp;</span> 比分 <span class="hljs-built_in">&amp;</span> 备注<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><span class="hljs-keyword">\hline</span> <span class="hljs-comment">%产生双横线</span><br>1st <span class="hljs-built_in">&amp;</span> RNG <span class="hljs-built_in">&amp;</span> 6-0 <span class="hljs-built_in">&amp;</span> 出线<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br>2nd <span class="hljs-built_in">&amp;</span> DK <span class="hljs-built_in">&amp;</span> 3-3 <span class="hljs-built_in">&amp;</span> 出线<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br>3rd <span class="hljs-built_in">&amp;</span> T1 <span class="hljs-built_in">&amp;</span> 2-4 <span class="hljs-built_in">&amp;</span> 淘汰<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br>4th <span class="hljs-built_in">&amp;</span> G2 <span class="hljs-built_in">&amp;</span> 1-5 <span class="hljs-built_in">&amp;</span> 淘汰<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>最终的效果如下：<br><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E6%B5%AE%E5%8A%A8%E4%BD%93.png" srcset="/img/loading.gif" lazyload alt="浮动体"></p><h3 id="1-7-数学公式"><a href="#1-7-数学公式" class="headerlink" title="1.7. 数学公式"></a>1.7. 数学公式</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;ctexart&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\section</span>&#123;简介&#125;<br><span class="hljs-keyword">\LaTeX</span>&#123;&#125;将排版内容分为文本模式和数学模式。文本模式用于普通文本排版，数学模式用于数学公式排版。<br><br><span class="hljs-keyword">\section</span>&#123;行内公式&#125;<br><span class="hljs-keyword">\subsection</span>&#123;美元符号&#125;<br>交换律：<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span>a+b=b+a<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-keyword">\subsection</span>&#123;小括号&#125;<br>交换律：<span class="hljs-keyword">\(</span>a+b=b+a<span class="hljs-keyword">\)</span><br> <span class="hljs-keyword">\subsection</span>&#123;math环境&#125;<br>交换律：<span class="hljs-keyword">\begin</span>&#123;math&#125;a+b=b+a<span class="hljs-keyword">\end</span>&#123;math&#125;<br><br><span class="hljs-keyword">\section</span>&#123;上下标&#125;<br>上：<span class="hljs-built_in">$</span>x<span class="hljs-built_in">^</span>&#123;2x<span class="hljs-built_in">^</span>&#123;6&#125;+1&#125;+y=0<span class="hljs-built_in">$</span> <span class="hljs-keyword">\\</span><br>下：<span class="hljs-built_in">$</span>a<span class="hljs-built_in">_</span>1,a<span class="hljs-built_in">_</span>2,a<span class="hljs-built_in">_</span>3...a<span class="hljs-built_in">_</span>&#123;100&#125;<span class="hljs-built_in">$</span> <br><br><span class="hljs-keyword">\section</span>&#123;希腊字母&#125;<br><span class="hljs-built_in">$</span><span class="hljs-keyword">\alpha</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\beta</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\gamma</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\epsilon</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\omega</span><span class="hljs-built_in">$</span><br><br>大写希腊字母：<br><span class="hljs-built_in">$</span><span class="hljs-keyword">\Gamma</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\Delta</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\Theta</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\Pi</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\Omega</span><span class="hljs-built_in">$</span><br><br><span class="hljs-keyword">\section</span>&#123;数学函数&#125;<br><span class="hljs-built_in">$</span><span class="hljs-keyword">\log</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\sin</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\cos</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\arcsin</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\arccos</span><span class="hljs-built_in">$</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\ln</span><span class="hljs-built_in">$</span> <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">$</span>y=<span class="hljs-keyword">\sin</span><span class="hljs-built_in">^</span>&#123;-1&#125;x<span class="hljs-built_in">$</span> <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">$</span>y=log<span class="hljs-built_in">_</span>2x<span class="hljs-built_in">$</span> <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\sqrt</span>[4]&#123;x<span class="hljs-built_in">^</span>2+y<span class="hljs-built_in">^</span>2&#125;<span class="hljs-built_in">$</span> <span class="hljs-comment">%[]可选参数，开方次数</span><br><br><span class="hljs-keyword">\section</span>&#123;分式&#125;<br><span class="hljs-built_in">$</span><span class="hljs-keyword">\frac</span>&#123;x&#125;&#123;x<span class="hljs-built_in">^</span>2+x+1&#125;<span class="hljs-built_in">$</span> <span class="hljs-keyword">\\</span> <span class="hljs-comment">%第一个可选参数是分子，第二个是分母</span><br><span class="hljs-built_in">$</span><span class="hljs-keyword">\sqrt</span>&#123;<span class="hljs-keyword">\frac</span>&#123;x&#125;&#123;x<span class="hljs-built_in">^</span>2+x&#125;&#125;<span class="hljs-built_in">$</span><br><br><span class="hljs-keyword">\section</span>&#123;行间公式&#125;<br><span class="hljs-keyword">\subsection</span>&#123;美元符号&#125;<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span>x+y=2<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> <span class="hljs-comment">%使用双$</span><br><span class="hljs-keyword">\subsection</span>&#123;中括号&#125;<br> <span class="hljs-keyword">\[</span>x+y=2<span class="hljs-keyword">\]</span> <span class="hljs-comment">%同样效果</span><br> <span class="hljs-keyword">\subsection</span>&#123;displaymath环境&#125;<br> <span class="hljs-keyword">\begin</span>&#123;displaymath&#125;<br> x+y=2<br> <span class="hljs-keyword">\end</span>&#123;displaymath&#125;<br> <br><span class="hljs-keyword">\section</span>&#123;自动编号公式equation环境&#125;<br>交换律见式<span class="hljs-keyword">\ref</span>&#123;eq:commutative&#125; <span class="hljs-comment">%交叉引用</span><br><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>a+b=b+a <span class="hljs-keyword">\label</span>&#123;eq:commutative&#125;<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br><br><span class="hljs-keyword">\section</span>&#123;不编号equation*环境&#125;<br>交换律见式：<span class="hljs-keyword">\ref</span>&#123;eq:commutative2&#125;:<br><span class="hljs-keyword">\begin</span>&#123;equation*&#125;<br>a+b=b+a  <span class="hljs-keyword">\label</span>&#123;eq:commutative2&#125;<br><span class="hljs-keyword">\end</span>&#123;equation*&#125;<br><span class="hljs-comment">%在公式末尾加\nonumber也可以去编号</span><br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>公式编号和交叉引用都是自动实现的，在排版中，要习惯采用自动化的方式处理注入图、表、公式的编号与交叉引用。</p><p>矩阵处理如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;ctexart&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%矩阵环境，用&amp;分割列，用\\分割行 每个矩阵前后需要加 \[ \]</span><br><span class="hljs-comment">%注意\[ \] 里面无需空行</span><br><span class="hljs-keyword">\[</span><br><span class="hljs-keyword">\begin</span>&#123;matrix&#125; <span class="hljs-comment">%无定界符</span><br>0<span class="hljs-built_in">&amp;</span>1<span class="hljs-keyword">\\</span><br>1<span class="hljs-built_in">&amp;</span>0<br><span class="hljs-keyword">\end</span>&#123;matrix&#125;<br><span class="hljs-keyword">\]</span><br><span class="hljs-keyword">\[</span><br>A=<span class="hljs-keyword">\begin</span>&#123;pmatrix&#125;<span class="hljs-comment">%小括号</span><br>a<span class="hljs-built_in">_</span>&#123;11&#125;<span class="hljs-built_in">^</span>2<span class="hljs-built_in">&amp;</span>a<span class="hljs-built_in">_</span>&#123;12&#125;<span class="hljs-built_in">^</span>2<span class="hljs-built_in">&amp;</span>a<span class="hljs-built_in">_</span>&#123;13&#125;<span class="hljs-built_in">^</span>2<span class="hljs-keyword">\\</span><br>0<span class="hljs-built_in">&amp;</span>a<span class="hljs-built_in">_</span>&#123;22&#125;<span class="hljs-built_in">&amp;</span>a<span class="hljs-built_in">_</span>&#123;23&#125; <span class="hljs-keyword">\\</span><br>0<span class="hljs-built_in">&amp;</span>0<span class="hljs-built_in">&amp;</span>a<span class="hljs-built_in">_</span>&#123;33&#125;<br><span class="hljs-keyword">\end</span>&#123;pmatrix&#125; <br><span class="hljs-keyword">\]</span><br><span class="hljs-keyword">\[</span><br><span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\begin</span>&#123;bmatrix&#125;<span class="hljs-comment">%中括号</span><br>0<span class="hljs-built_in">&amp;</span>-1<span class="hljs-keyword">\\</span><br>3<span class="hljs-built_in">&amp;</span>1<br><span class="hljs-keyword">\end</span>&#123;bmatrix&#125;<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\begin</span>&#123;Bmatrix&#125;<span class="hljs-comment">%大括号</span><br>0<span class="hljs-built_in">&amp;</span>-1<span class="hljs-keyword">\\</span><br>3<span class="hljs-built_in">&amp;</span>1<br>17<br><span class="hljs-keyword">\end</span>&#123;Bmatrix&#125;<br><span class="hljs-keyword">\begin</span>&#123;vmatrix&#125;<span class="hljs-comment">%单竖线</span><br>0<span class="hljs-built_in">&amp;</span>-1<span class="hljs-keyword">\\</span><br>3<span class="hljs-built_in">&amp;</span>1<br><span class="hljs-keyword">\end</span>&#123;vmatrix&#125;<br><span class="hljs-keyword">\begin</span>&#123;Vmatrix&#125;<span class="hljs-comment">%双竖线</span><br>0<span class="hljs-built_in">&amp;</span>-1<span class="hljs-keyword">\\</span><br>3<span class="hljs-built_in">&amp;</span>1<br><span class="hljs-keyword">\end</span>&#123;Vmatrix&#125;<br><span class="hljs-keyword">\]</span><br><span class="hljs-comment">%常用省略号： \dots 横向 \ddots 对角线 \vdots 竖线</span><br><span class="hljs-keyword">\[</span><br>B=<span class="hljs-keyword">\begin</span>&#123;bmatrix&#125;<br>b<span class="hljs-built_in">_</span>&#123;11&#125; <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\dots</span> <span class="hljs-built_in">&amp;</span> b<span class="hljs-built_in">_</span>&#123;1n&#125;<span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\ddots</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\vdots</span> <span class="hljs-keyword">\\</span><br>0 <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\dots</span> <span class="hljs-built_in">&amp;</span> b<span class="hljs-built_in">_</span>&#123;nn&#125;<br><span class="hljs-keyword">\end</span>&#123;bmatrix&#125;<span class="hljs-built_in">_</span>&#123;n<span class="hljs-keyword">\times</span> n&#125; <span class="hljs-comment">%\times 是乘号 (X)</span><br><span class="hljs-keyword">\]</span><br><span class="hljs-comment">%分块矩阵（矩阵镶套）</span><br><span class="hljs-keyword">\[</span><br>C=<span class="hljs-keyword">\begin</span>&#123;pmatrix&#125;<br><span class="hljs-keyword">\begin</span>&#123;matrix&#125; 0<span class="hljs-built_in">&amp;</span>1<span class="hljs-keyword">\\</span>1<span class="hljs-built_in">&amp;</span>-1 <span class="hljs-keyword">\end</span>&#123;matrix&#125;<br><span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\text</span>&#123;<span class="hljs-keyword">\Large</span> 0&#125; <span class="hljs-keyword">\\</span> <span class="hljs-comment">%text用于在数学模式中临时切换为文本模式</span><br><span class="hljs-keyword">\text</span>&#123;<span class="hljs-keyword">\Large</span> 0&#125; <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\begin</span>&#123;matrix&#125; 1<span class="hljs-built_in">&amp;</span>0 <span class="hljs-keyword">\\</span> 0<span class="hljs-built_in">&amp;</span> -2 <span class="hljs-keyword">\end</span>&#123;matrix&#125;<br><span class="hljs-keyword">\end</span>&#123;pmatrix&#125;<br><span class="hljs-keyword">\]</span><br><span class="hljs-comment">% 括号包裹的矩阵</span><br><span class="hljs-keyword">\[</span><span class="hljs-keyword">\begin</span>&#123;pmatrix&#125;<br>a<span class="hljs-built_in">_</span>&#123;11&#125;<span class="hljs-built_in">&amp;</span>a<span class="hljs-built_in">_</span>&#123;12&#125;<span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\cdots</span><span class="hljs-built_in">&amp;</span>a<span class="hljs-built_in">_</span>&#123;ln&#125;<span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span>a<span class="hljs-built_in">_</span>&#123;22&#125;<span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\cdots</span><span class="hljs-built_in">&amp;</span>a<span class="hljs-built_in">_</span>&#123;2n&#125;<span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span><span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\dots</span> <span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\vdots</span> <span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\multicolumn</span>&#123;2&#125;&#123;c&#125;&#123;<span class="hljs-keyword">\raisebox</span>&#123;1.3ex&#125;[0pt]&#123;<span class="hljs-keyword">\Huge</span> 0&#125;&#125; <span class="hljs-comment">%muticolumn合并多列 raisebox调整高度</span><br><span class="hljs-built_in">&amp;</span><span class="hljs-built_in">&amp;</span>a<span class="hljs-built_in">_</span>&#123;nn&#125;<br><span class="hljs-keyword">\end</span>&#123;pmatrix&#125;<br><span class="hljs-keyword">\]</span><br><span class="hljs-comment">% 跨列的省略号：\hdotsfor&#123;&lt;列数&gt;&#125;</span><br><span class="hljs-keyword">\[</span><span class="hljs-keyword">\begin</span>&#123;pmatrix&#125;<br>1<span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\frac</span> 12 <span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\dots</span> <span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\frac</span> 1n <span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hdotsfor</span>&#123;4&#125;<span class="hljs-keyword">\\</span><br>m<span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\frac</span> m2<span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\dots</span> <span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\frac</span> mn<br><span class="hljs-keyword">\end</span>&#123;pmatrix&#125;<br><span class="hljs-keyword">\]</span><br><span class="hljs-comment">% 行内小矩阵(smallmatrix)环境</span><br>复数<span class="hljs-built_in">$</span>z=(x,y)<span class="hljs-built_in">$</span>也可以用矩阵<br><span class="hljs-keyword">\begin</span>&#123;math&#125;<br><span class="hljs-keyword">\left</span>(<span class="hljs-comment">% 需手动加上左括号</span><br><span class="hljs-keyword">\begin</span>&#123;smallmatrix&#125;<br>x <span class="hljs-built_in">&amp;</span>-y<span class="hljs-keyword">\\</span>y <span class="hljs-built_in">&amp;</span>x<br><span class="hljs-keyword">\end</span>&#123;smallmatrix&#125;<br><span class="hljs-keyword">\right</span>)<span class="hljs-comment">% 需手动加上右括号</span><br><span class="hljs-keyword">\end</span>&#123;math&#125;来表示<br><br><span class="hljs-comment">% array环境(类似表格环境tabular)</span><br><span class="hljs-keyword">\[</span><br><span class="hljs-keyword">\begin</span>&#123;array&#125;&#123;r|r&#125;<br><span class="hljs-keyword">\frac</span> 12<span class="hljs-built_in">&amp;</span>0<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br>0<span class="hljs-built_in">&amp;</span> -<span class="hljs-keyword">\frac</span> a&#123;bc&#125;<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\end</span>&#123;array&#125;<br><span class="hljs-keyword">\]</span><br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>多行公式处理如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;amssymb&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">% gather和gather*环境实现多行公式的排版(可以使用\\换行)</span><br><span class="hljs-comment">% 带编号</span><br><span class="hljs-keyword">\begin</span>&#123;gather&#125;<br>a + b = b + a<span class="hljs-keyword">\\</span><br>ab  ba<br><span class="hljs-keyword">\end</span>&#123;gather&#125;<br><br><span class="hljs-comment">% 不带编号</span><br><span class="hljs-keyword">\begin</span>&#123;gather*&#125;<br>3+5 = 5+3 = 8<span class="hljs-keyword">\\</span><br>3 <span class="hljs-keyword">\times</span> 5=5 <span class="hljs-keyword">\times</span> 3<br><span class="hljs-keyword">\end</span>&#123;gather*&#125;<br><br><span class="hljs-comment">% 在\\前使用\notag阻止编号</span><br><span class="hljs-keyword">\begin</span>&#123;gather&#125;<br>3<span class="hljs-built_in">^</span>2 + 4<span class="hljs-built_in">^</span>2 = 5<span class="hljs-built_in">^</span>2 <span class="hljs-keyword">\notag</span> <span class="hljs-keyword">\\</span><br>a<span class="hljs-built_in">^</span>2 + b<span class="hljs-built_in">^</span>2 = c<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\end</span>&#123;gather&#125;<br><br><span class="hljs-comment">% align和align*环境使公式在指定位置对齐(用&amp;符号指定对齐位置)</span><br><span class="hljs-comment">% 带编号</span><br><span class="hljs-keyword">\begin</span>&#123;align&#125;<br>x <span class="hljs-built_in">&amp;</span>=t+<span class="hljs-keyword">\cos</span> t+1<span class="hljs-keyword">\\</span> <span class="hljs-comment">%按等号对齐</span><br>y <span class="hljs-built_in">&amp;</span>=2 <span class="hljs-keyword">\sin</span> t<br><span class="hljs-keyword">\end</span>&#123;align&#125;<br><span class="hljs-comment">% 不带编号</span><br><span class="hljs-keyword">\begin</span>&#123;align*&#125;<br>x <span class="hljs-built_in">&amp;</span>= t <span class="hljs-built_in">&amp;</span> x <span class="hljs-built_in">&amp;</span>= <span class="hljs-keyword">\cos</span> t <span class="hljs-built_in">&amp;</span> x <span class="hljs-built_in">&amp;</span>= t <span class="hljs-keyword">\\</span><br>y <span class="hljs-built_in">&amp;</span>= 2t <span class="hljs-built_in">&amp;</span> y <span class="hljs-built_in">&amp;</span>= <span class="hljs-keyword">\sin</span>(t+1) <span class="hljs-built_in">&amp;</span> y <span class="hljs-built_in">&amp;</span>= <span class="hljs-keyword">\sin</span> t<br><span class="hljs-keyword">\end</span>&#123;align*&#125;<br><br><span class="hljs-comment">% split环境(对齐采用align环境的方式，编号在中间)</span><br><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br><span class="hljs-keyword">\begin</span>&#123;split&#125; <span class="hljs-comment">%实现一个公式的多行排版</span><br><span class="hljs-keyword">\cos</span> 2x <span class="hljs-built_in">&amp;</span>=<span class="hljs-keyword">\cos</span><span class="hljs-built_in">^</span>2 x- <span class="hljs-keyword">\sin</span><span class="hljs-built_in">^</span>2 x<span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span>=2<span class="hljs-keyword">\cos</span><span class="hljs-built_in">^</span>2 x-1<br><span class="hljs-keyword">\end</span>&#123;split&#125;<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br><br><span class="hljs-comment">% case环境（实现分段函数的排版）</span><br><span class="hljs-comment">% 每行公式中使用&amp;分隔为两部分</span><br><span class="hljs-comment">% 通常表示值和后面的条件</span><br><span class="hljs-comment">% \text&#123;&#125;在数学模式中处理中文或者临时切换为文本模式</span><br><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>D(x)=<span class="hljs-keyword">\begin</span>&#123;cases&#125;<br>1,<span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\text</span>&#123;如果&#125; x <span class="hljs-keyword">\in</span> <span class="hljs-keyword">\mathbb</span>&#123;Q&#125;;<span class="hljs-keyword">\\</span><br>0,<span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\text</span>&#123;如果&#125; x <span class="hljs-keyword">\in</span> <span class="hljs-keyword">\mathbb</span>&#123;R&#125;<span class="hljs-keyword">\setminus</span><span class="hljs-keyword">\mathbb</span>&#123;Q&#125;<br><span class="hljs-keyword">\end</span>&#123;cases&#125;<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-8-Latex中的参考文献"><a href="#1-8-Latex中的参考文献" class="headerlink" title="1.8. Latex中的参考文献"></a>1.8. Latex中的参考文献</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">% 一次管理,一次使用</span><br><span class="hljs-comment">% 参考文献格式:</span><br><span class="hljs-comment">% \begin&#123;thebibliography&#125;&#123;编号样本&#125;</span><br><span class="hljs-comment">% \bibitem[记号]&#123;引用标志&#125;文献条目1</span><br><span class="hljs-comment">% \bibitem[记号]&#123;引用标志&#125;文献条目2</span><br><span class="hljs-comment">% ……</span><br><span class="hljs-comment">% \end&#123;thebibliography &#125;</span><br><span class="hljs-comment">% 其中文献条目包括:作者，题目，出版社，年代，版本，页码等。</span><br><span class="hljs-comment">% 引用时候要可以采用:\cite&#123;引用标志1，引用标志2，...&#125;</span><br>引用一篇文章<span class="hljs-keyword">\cite</span>&#123;article1&#125;,引用一本书<span class="hljs-keyword">\cite</span>&#123;book1&#125;<br><span class="hljs-keyword">\begin</span>&#123;thebibliography&#125;&#123;99&#125;<br><span class="hljs-keyword">\bibitem</span>&#123;article1&#125;陈立耀,苏伟,蔡川,陈晓云.<span class="hljs-keyword">\emph</span>&#123;基于LaTex的Web数堂公式提取方法研究&#125;[1]、让算机科学、2014(06)<br><span class="hljs-keyword">\bibitem</span>&#123;book1&#125;william H. Press,saul A.Teukolsky, william T. Metterling, Brian P. Elannery,<span class="hljs-keyword">\emph</span>&#123;Numerical Recipes 3rd Edition:The Art of Scientific Computing&#125;Cambridge University Press,New York,2007.<br><span class="hljs-keyword">\bibitem</span>&#123;latexGuide&#125; Kopka Helmut，w. Daly Patrick,<span class="hljs-keyword">\emph</span>&#123;Guide to <span class="hljs-keyword">\LaTeX</span>&#125;，<span class="hljs-built_in">$</span>4<span class="hljs-built_in">^</span>&#123;th&#125;<span class="hljs-built_in">$</span> Edition.Available at <span class="hljs-keyword">\texttt</span>&#123;http://www.amazon.com&#125;.<br><span class="hljs-keyword">\bibitem</span>&#123;latexMath&#125; Graetzer George，lemph&#123;Math Into <span class="hljs-keyword">\LaTeX</span>&#125;,BirkhAuser Boston; 3 edition (une 22，2000).<br><span class="hljs-keyword">\end</span>&#123;thebibliography&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Beamer基础用法"><a href="#2-Beamer基础用法" class="headerlink" title="2. Beamer基础用法"></a>2. Beamer基础用法</h2><h3 id="2-1-如何用Beamer创建标签页"><a href="#2-1-如何用Beamer创建标签页" class="headerlink" title="2.1. 如何用Beamer创建标签页"></a>2.1. 如何用Beamer创建标签页</h3><p>Beamer是一个非常强大的Slides制作工具，那么我们该如何利用它来做出优美的Slides呢？</p><p>首先我们需要声明这是一个Beamer演示文稿：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;beamer&#125;<br></code></pre></td></tr></table></figure><p>之后在我们文档下边可以添加title, author, institute, date等信息：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;beamer&#125;<br><span class="hljs-keyword">\title</span>&#123;Example&#125;<br><span class="hljs-keyword">\author</span>&#123;Xyw&#125;<br><span class="hljs-keyword">\institute</span>&#123;BUPT&#125;<br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%A6%96%E9%A1%B5.png" srcset="/img/loading.gif" lazyload alt="首页"></p><p>在<code>\begin&#123;document&#125; ... \end&#123;document&#125;</code>中，可以存放所有的Slides内容。</p><p>那么我们先放一个<code>\frame&#123;\titlepage&#125;</code>，这个命令会帮我们创建标签页。</p><p>那么我们现在想做一个略微复杂一些的标签页：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;beamer&#125;<br><br><span class="hljs-keyword">\title</span>[Advanced] &#123;This is an advanced titlepage&#125;<br><span class="hljs-keyword">\subtitle</span>&#123;A beautiful slide&#125;<br><span class="hljs-keyword">\author</span>[Xyw, John, Tom] <span class="hljs-comment">%(optional, you can add more authors)</span><br>&#123;A.~B.~Xyw<span class="hljs-keyword">\inst</span>&#123;1&#125; <span class="hljs-keyword">\ </span>and J.John<span class="hljs-keyword">\inst</span>&#123;2&#125;&#125;<br><span class="hljs-keyword">\institute</span>[VFU] <span class="hljs-comment">%(optional)</span><br>&#123;<br>    <span class="hljs-keyword">\inst</span>&#123;1&#125; <span class="hljs-comment">%</span><br>    Computer and Technology <span class="hljs-keyword">\\</span><br>    Beijing University of Posts and Telecommunication<br>    <span class="hljs-keyword">\and</span> <br>    <span class="hljs-keyword">\inst</span>&#123;2&#125; <span class="hljs-comment">%</span><br>    Computer and Technology <span class="hljs-keyword">\\</span><br>    Very Famous University<br>&#125;<br><span class="hljs-keyword">\date</span>[VLC 2024] <span class="hljs-comment">% (optional)</span><br>&#123;<br>    Very Large Conference, <span class="hljs-keyword">\today</span><br>&#125;<br><span class="hljs-keyword">\logo</span>&#123;<span class="hljs-keyword">\includegraphics</span>[scale=0.1]&#123;figures/image.png&#125;&#125;<br><span class="hljs-keyword">\usetheme</span>&#123;Madrid&#125;<br><span class="hljs-keyword">\usecolortheme</span>&#123;beaver&#125; <span class="hljs-comment">%一个主题可以与一个颜色主题相结合，以改变不同元素使用的颜色</span><br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%标题页</span><br><span class="hljs-keyword">\frame</span>&#123;<span class="hljs-keyword">\titlepage</span>&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br><br></code></pre></td></tr></table></figure><p>一个略微优雅的标签页就被我们设计好啦！<br><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E4%BC%98%E9%9B%85%E7%9A%84%E6%A0%87%E7%AD%BE%E9%A1%B5.png" srcset="/img/loading.gif" lazyload alt="优雅的标签页"></p><h3 id="2-2-如何加入更多元素"><a href="#2-2-如何加入更多元素" class="headerlink" title="2.2. 如何加入更多元素"></a>2.2. 如何加入更多元素</h3><p>在Beamer中，最基础的元素是frame，一个frame可能包含多个页。完整的Beamer创建页如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;beamer&#125;<br><span class="hljs-keyword">\title</span>&#123;Example&#125;<br><span class="hljs-keyword">\author</span>&#123;Xyw&#125;<br><span class="hljs-keyword">\institute</span>&#123;BUPT&#125;<br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br>    <span class="hljs-keyword">\frame</span>&#123;<span class="hljs-keyword">\titlepage</span>&#125;<br><br>    <span class="hljs-keyword">\begin</span>&#123;frame&#125;<br>    <span class="hljs-keyword">\frametitle</span>&#123;Sample frame title&#125;<br>    This is some text in the first frame. This is some text in the first frame. This is some text in the first frame.<br>    <span class="hljs-keyword">\end</span>&#123;frame&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>Beamer类提供了许多工具来帮助我们创建漂亮的Slides。</p><ul><li>单行内容：<code>\frame&#123;xxx&#125;</code></li><li>多行内容：<code>\begin&#123;frame&#125; xxx \end&#123;frame&#125;</code></li></ul><p>通过<code>\usetheme&#123;xxx&#125;</code>去指定所使用的主题，beamer内置了许多种不同的主题。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;beamer&#125;<br><br><span class="hljs-keyword">\title</span>&#123;Sample title&#125;<br><span class="hljs-keyword">\author</span>&#123;Anonymous&#125;<br><span class="hljs-keyword">\institute</span>&#123;Overleaf&#125;<br><span class="hljs-keyword">\date</span>&#123;2021&#125;<br><br><span class="hljs-keyword">\usetheme</span>&#123;Madrid&#125;<br><span class="hljs-keyword">\usecolortheme</span>&#123;beaver&#125; <span class="hljs-comment">%一个主题可以与一个颜色主题相结合，以改变不同元素使用的颜色</span><br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%标题页</span><br><span class="hljs-keyword">\frame</span>&#123;<span class="hljs-keyword">\titlepage</span>&#125;<br><br><span class="hljs-comment">%slide页面</span><br><span class="hljs-keyword">\begin</span>&#123;frame&#125;<br><span class="hljs-keyword">\frametitle</span>&#123;Sample frame title&#125;<br>This is some text in the first frame. This is some text in the first frame. This is some text in the first frame.<br><span class="hljs-keyword">\end</span>&#123;frame&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B2%E7%9A%84%E6%A0%87%E7%AD%BE%E9%A1%B5.png" srcset="/img/loading.gif" lazyload alt="改变颜色的标签页"></p><h3 id="2-3-创建一个目录"><a href="#2-3-创建一个目录" class="headerlink" title="2.3. 创建一个目录"></a>2.3. 创建一个目录</h3><p>如果Slides有非常多，可以加入一个目录页来展示PPT章节：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;frame&#125;<br><span class="hljs-keyword">\frametitle</span>&#123;Table of Contents&#125;<br><span class="hljs-keyword">\tableofcontents</span><br><span class="hljs-keyword">\end</span>&#123;frame&#125;<br></code></pre></td></tr></table></figure><p>我们也可以在每一章前面加入一个目录，然后高亮当前的目录。具体来说，在文档的导言区加入以下命令：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\AtBeginSection</span>[]<br>&#123;<br>    <span class="hljs-keyword">\begin</span>&#123;frame&#125;<br>        <span class="hljs-keyword">\frametitle</span>&#123;Table of Contents&#125;<br>        <span class="hljs-keyword">\tableofcontents</span>[currentsection]<br>    <span class="hljs-keyword">\end</span>&#123;frame&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上边的如果是<code>\AtBeginSubsection[]</code>，那么目录会出现在每一个子章节之前。</p><h3 id="2-4-Beamer强调"><a href="#2-4-Beamer强调" class="headerlink" title="2.4. Beamer强调"></a>2.4. Beamer强调</h3><p>在PPT中我们可能会对某些内容进行强调，可以用一些框框来对它进行标注：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;beamer&#125;<br><br><span class="hljs-keyword">\title</span>&#123;Sample title&#125;<br><span class="hljs-keyword">\author</span>&#123;Anonymous&#125;<br><span class="hljs-keyword">\institute</span>&#123;Overleaf&#125;<br><span class="hljs-keyword">\date</span>&#123;2021&#125;<br><br><span class="hljs-keyword">\usetheme</span>&#123;Madrid&#125;<br><span class="hljs-keyword">\usecolortheme</span>&#123;beaver&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%标题页</span><br><span class="hljs-keyword">\frame</span>&#123;<span class="hljs-keyword">\titlepage</span>&#125;<br><br><span class="hljs-comment">%slide页面</span><br><span class="hljs-keyword">\begin</span>&#123;frame&#125;<br><span class="hljs-keyword">\frametitle</span>&#123;Sample frame title&#125;<br>This is some text in the first frame. This is some text in the first frame. This is some text in the first frame.<br><span class="hljs-keyword">\end</span>&#123;frame&#125;<br><br><span class="hljs-comment">%slide页面2</span><br><span class="hljs-keyword">\begin</span>&#123;frame&#125;<br><span class="hljs-keyword">\frametitle</span>&#123;Sample frame title&#125;<br><br>In this slide, some important text will be<br><span class="hljs-keyword">\alert</span>&#123;highlighted&#125; because it&#x27;s important.<br>Please, don&#x27;t abuse it.<br><br><span class="hljs-keyword">\begin</span>&#123;block&#125;&#123;Remark&#125;<br>Sample text<br><span class="hljs-keyword">\end</span>&#123;block&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;alertblock&#125;&#123;Important theorem&#125;<br>Sample text in red box<br><span class="hljs-keyword">\end</span>&#123;alertblock&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;examples&#125;<br>Sample text in green box. The title of the block is ``Examples&quot;.<br><span class="hljs-keyword">\end</span>&#123;examples&#125;<br><span class="hljs-keyword">\end</span>&#123;frame&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/08/24/3-3-Beamer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%BC%BA%E8%B0%83%E6%A1%86.png" srcset="/img/loading.gif" lazyload alt="强调框"></p><p>如果要强调一整段文字，例如概念、定义、定理等等，最好的方法是把他们放在一个文本框中。我们可以定义三种文本框：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;block&#125;&#123;Remark&#125; <span class="hljs-keyword">\end</span>&#123;block&#125;<br><span class="hljs-keyword">\begin</span>&#123;alertblock&#125;&#123;Important theorem&#125; <span class="hljs-keyword">\end</span>&#123;alertblock&#125;<br><span class="hljs-keyword">\begin</span>&#123;examples&#125; <span class="hljs-keyword">\end</span>&#123;examples&#125;<br></code></pre></td></tr></table></figure><p>感谢你能看到这里，在未来的学习中，我们会用一套模板来设计PPT，并将会放在下方。</p>]]></content>
    
    
    <categories>
      
      <category>美化系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Beamer Latex Slides</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V杭州峰会记录</title>
    <link href="/2024/08/21/1-4-RISC-V%E6%9D%AD%E5%B7%9E%E5%B3%B0%E4%BC%9A%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/08/21/1-4-RISC-V%E6%9D%AD%E5%B7%9E%E5%B3%B0%E4%BC%9A%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-21号下午场的部分分享"><a href="#1-21号下午场的部分分享" class="headerlink" title="1. 21号下午场的部分分享"></a>1. 21号下午场的部分分享</h1><h1 id="1-赛昉科技-刘文进"><a href="#1-赛昉科技-刘文进" class="headerlink" title="1. 赛昉科技-刘文进"></a>1. 赛昉科技-刘文进</h1><p><strong>缩写：什么是PPA？</strong></p><blockquote><p><strong>Performance</strong>, <strong>Power</strong>, <strong>Area</strong>，PPA字面意思只是这三个名词的首字母缩写，但实际上指的是性能、功耗、面积的综合考量，并且相互之间会有影响。</p></blockquote><p>RISC-V在数据中心的关键布局中，最关键的是<code>CPU</code>和<code>NOC</code></p><p><strong>缩写：什么是NOC？</strong></p><blockquote><p>片上网络互连（Network-on-Chip，NoC）是集成电路上的一种基于网络的通信子系统，用于SoC中的模块之间，基于路由器的分组交换网络，连接SoC各模块</p></blockquote><p><img src="/2024/08/21/1-4-RISC-V%E6%9D%AD%E5%B7%9E%E5%B3%B0%E4%BC%9A%E8%AE%B0%E5%BD%95/RISC-V%E6%AD%A5%E5%85%A5%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E6%9C%BA%E9%81%87.jpg" srcset="/img/loading.gif" lazyload alt="RISC-V步入数据中心的机遇"></p><p><img src="/2024/08/21/1-4-RISC-V%E6%9D%AD%E5%B7%9E%E5%B3%B0%E4%BC%9A%E8%AE%B0%E5%BD%95/%E8%B5%9B%E6%98%89%E7%A7%91%E6%8A%80IP%E5%8F%91%E5%B1%95%E5%9B%BE.jpg" srcset="/img/loading.gif" lazyload alt="赛昉科技IP发展图"></p><h1 id="2-Vice’s-Shreyas-Derashri"><a href="#2-Vice’s-Shreyas-Derashri" class="headerlink" title="2. Vice’s Shreyas Derashri"></a>2. Vice’s Shreyas Derashri</h1><p>这个公司主要在做RISC-V的GPU，这个是他们的产品发展图。</p><h1 id="3-香山服务器IP当前状态和路线图"><a href="#3-香山服务器IP当前状态和路线图" class="headerlink" title="3. 香山服务器IP当前状态和路线图"></a>3. 香山服务器IP当前状态和路线图</h1><p>香山单核还可以，但是多核差距很大<br><strong>多核特性</strong>：满足多核扩展性；满足CPU与PCIe的双向数据传输；满足多通道memory优化；对性能做建模</p><p><img src="/2024/08/21/1-4-RISC-V%E6%9D%AD%E5%B7%9E%E5%B3%B0%E4%BC%9A%E8%AE%B0%E5%BD%95/%E9%A6%99%E5%B1%B1%E8%AE%A1%E5%88%92%E5%9B%BE.jpg" srcset="/img/loading.gif" lazyload alt="香山计划图"></p><h1 id="4-昆明湖架构"><a href="#4-昆明湖架构" class="headerlink" title="4. 昆明湖架构"></a>4. 昆明湖架构</h1><p>核心内容：<strong>PPA+产品化交付</strong><br>支持H和V扩展，支持48位虚拟地址，RVA23的profile。<br><strong>虚拟化H扩展</strong>：CPU虚拟化+内存虚拟化<br><strong>向量V扩展</strong>：提供SIMD，支持整数、FP64、FP32、FP16，支持LMUL配置。基于simpoint的向量性能比标量提升24%<br><strong>RVA23 Profile</strong>：安全(Zkt&#x2F;Zvkt)+功能+性能+功耗+调试</p><p>昆明湖在前端、后端、仿存和缓存都有性能改善和提升。</p><p>验证在硬件开发流程中占据重要地位</p><ul><li>硅前验证</li><li>硅后验证</li></ul><p>他们的团队人非常多，流程非常完整，相比较我自己的研究方向来说，感觉在科研方向领域的帮助不是很大。<br><img src="/2024/08/21/1-4-RISC-V%E6%9D%AD%E5%B7%9E%E5%B3%B0%E4%BC%9A%E8%AE%B0%E5%BD%95/%E6%98%86%E6%98%8E%E6%B9%96%E7%A1%85%E5%89%8D%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" lazyload alt="昆明湖硅前验证流程"></p><h1 id="5-昆明湖架构向量扩展的设计与演进"><a href="#5-昆明湖架构向量扩展的设计与演进" class="headerlink" title="5. 昆明湖架构向量扩展的设计与演进"></a>5. 昆明湖架构向量扩展的设计与演进</h1><p>传统SIMD使用特定向量长度，对应特定的向量寄存器位宽。如果软件是用短向量长度，硬件长SIMD，寄存器会浪费；反之程序并行度会很低。传统的向量扩展不够灵活。</p><p>RISC-V向量计算：寄存器组，一条指令操作多个向量寄存器，可变长的向量长度，指令与向量寄存器宽度无关，保证软硬件解耦；还支持谓词操作以及丰富访存模式。</p><p><img src="/2024/08/21/1-4-RISC-V%E6%9D%AD%E5%B7%9E%E5%B3%B0%E4%BC%9A%E8%AE%B0%E5%BD%95/%E9%A6%99%E5%B1%B1%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E5%90%8E%E7%AB%AF%E4%BB%8B%E7%BB%8D.jpg" srcset="/img/loading.gif" lazyload alt="香山向量处理后端介绍"></p><p>香山进行了诸多优化</p><ol><li>消除向量配置指令vset控制依赖，使用阻塞流水线（性能损失）或者建立向量配置寄存器vtype的更新与恢复</li><li>消除假的数据依赖</li><li>消除向量访存地址依赖</li><li>提高访存带宽</li></ol><h1 id="6-GPGPU介绍-何虎"><a href="#6-GPGPU介绍-何虎" class="headerlink" title="6. GPGPU介绍 何虎"></a>6. GPGPU介绍 何虎</h1><p>利用开源指令集构造开源GPGPU<br><a href="https://opengpgpu.org.cn/">https://opengpgpu.org.cn/</a><br>之后总结，非常diao</p><p>苏州国芯：通用图形处理单元GPGPU<br>关于OpenCL编译器的技术栈</p>]]></content>
    
    
    <categories>
      
      <category>开会心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V杭州峰会 开会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2_6-小说如何写刀子</title>
    <link href="/2024/08/19/2-6-%E5%B0%8F%E8%AF%B4%E5%A6%82%E4%BD%95%E5%86%99%E5%88%80%E5%AD%90/"/>
    <url>/2024/08/19/2-6-%E5%B0%8F%E8%AF%B4%E5%A6%82%E4%BD%95%E5%86%99%E5%88%80%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="1-写作素材大全"><a href="#1-写作素材大全" class="headerlink" title="1. 写作素材大全"></a>1. 写作素材大全</h1><h2 id="1-1-怎么写小说才能刀刀入骨？"><a href="#1-1-怎么写小说才能刀刀入骨？" class="headerlink" title="1.1. 怎么写小说才能刀刀入骨？"></a>1.1. 怎么写小说才能刀刀入骨？</h2><ol><li>上位者卑微到尘埃、高傲者求而不得</li><li>浪荡者死于忠贞、计谋家死于忠诚</li><li>偷窃者死于奉献、自私者死于牺牲</li><li>青梅竹马反目成仇、一见钟情身不由己</li><li>双向暗恋永远错过，朝夕相处各怀鬼胎</li><li>幡然醒悟无法挽回，久别重逢物是人非</li><li>生错的时代，杀错的恋人，背负的责任，叛徒的牺牲</li><li>命定的结局、懦夫的血勇、解不开的误会、等不来的道歉</li><li>你是我的整个青春，缺永远缺席我的未来</li><li>梦里是见你的唯一方式</li><li>欲言又止的次数太多，开口的冲动都没了</li><li>从哭的夜不能寐的那一刻起，我们就两清了</li><li>输半子的执棋者</li></ol><p>…</p>]]></content>
    
    
    <categories>
      
      <category>写作素材</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刀刀入骨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-Chisel剩余模块设计</title>
    <link href="/2024/08/19/1-3-Chisel%E5%89%A9%E4%BD%99%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/08/19/1-3-Chisel%E5%89%A9%E4%BD%99%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Chisel实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3_2-如何在Ubuntu上设置好看的壁纸</title>
    <link href="/2024/08/18/3-2-%E5%A6%82%E4%BD%95%E5%9C%A8Ubuntu%E4%B8%8A%E8%AE%BE%E7%BD%AE%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%A3%81%E7%BA%B8/"/>
    <url>/2024/08/18/3-2-%E5%A6%82%E4%BD%95%E5%9C%A8Ubuntu%E4%B8%8A%E8%AE%BE%E7%BD%AE%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%A3%81%E7%BA%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu壁纸设置"><a href="#Ubuntu壁纸设置" class="headerlink" title="Ubuntu壁纸设置"></a>Ubuntu壁纸设置</h1><h2 id="1-Komorebi软件"><a href="#1-Komorebi软件" class="headerlink" title="1. Komorebi软件"></a>1. Komorebi软件</h2><p>众所周知，我们可以在Windows中愉快的使用Wallpaper来设置我们的壁纸，但是在Wallpaper并不支持Ubuntu，那我们该如何设置美美的动态壁纸呢？</p><p>有这么一个软件：Komorebi，它可以在Ubuntu上边支持图片、视频、网页三种格式。</p><p>这个博客是一个比较好的安装指南：<a href="https://blog.csdn.net/yqqsyjnh/article/details/120576759">如何在Ubuntu系统上设置好看的动态壁纸</a></p><p>里边也有如何设置动态壁纸，我还可以给大家推荐一个免费壁纸的网站<a href="https://pixabay.com/zh/">pixabay</a></p>]]></content>
    
    
    <categories>
      
      <category>美化系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>壁纸</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-ubuntu美化小技巧</title>
    <link href="/2024/08/18/3-1-ubuntu%E7%BE%8E%E5%8C%96%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/08/18/3-1-ubuntu%E7%BE%8E%E5%8C%96%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu桌面美化"><a href="#Ubuntu桌面美化" class="headerlink" title="Ubuntu桌面美化"></a>Ubuntu桌面美化</h1><p>刚刚安装好Ubuntu，第一件事就是看看能不能美美的配置一下桌面环境，我在这里使用的是Gnome来进行配置。</p><p>首先我们需要安装GNOME Tweaks Tool<br>可以参考这个博客：<br><a href="https://blog.csdn.net/qq_35395195/article/details/125266461">Ubuntu桌面美化教程</a></p><p>但是我们发现有时候在Gnome的配置中会找不到所在的扩展，这个时候可以参考这个博客来解决：<a href="https://blog.csdn.net/ksws0292756/article/details/79936965">Ubuntu桌面环境找不到extension插件选项</a></p><p>安装好这两个之后，我们便可以下载诸多插件，同时安装相应的环境。</p><p>在准备好上述条件之后，我们可以选择许多现成的主题来更换，可以参考这个博客：<a href="https://blog.csdn.net/Simon55968/article/details/108921265">Ubuntu更换主题美化教程</a></p><p>至此我们便可以进行简单的主题配置，更多内容大家可以自行查阅。</p>]]></content>
    
    
    <categories>
      
      <category>美化系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu桌面美化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-网文写作书单</title>
    <link href="/2024/08/17/2_5-%E7%BD%91%E6%96%87%E5%86%99%E4%BD%9C%E4%B9%A6%E5%8D%95/"/>
    <url>/2024/08/17/2_5-%E7%BD%91%E6%96%87%E5%86%99%E4%BD%9C%E4%B9%A6%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-科幻类书单"><a href="#1-科幻类书单" class="headerlink" title="1. 科幻类书单"></a>1. 科幻类书单</h1><table><thead><tr><th>名称</th><th>简介</th><th>特点</th></tr></thead><tbody><tr><td>科幻创作百科全书</td><td>盘点了120个科幻元素</td><td>对每个元素都进行了详细的解释，来源，理论支撑，特定的学说，科幻词典</td></tr><tr><td>詹姆斯卡梅隆的科幻故事</td><td>卡梅隆的工作记录</td><td>纪录片的采访</td></tr><tr><td>一想到还有95%的问题留给人类我就放心了</td><td>反向科普，虫洞、暗物质、能量等都讲到了</td><td>适合软科幻</td></tr><tr><td>一个天文学家夜空漫游指南</td><td>把物理现象写的很诗意</td><td>观测日记</td></tr><tr><td>真实世界的脉络</td><td>多重宇宙、量子理论等，印象生成器</td><td>硬核</td></tr><tr><td>隐藏的现实</td><td>介绍了9种平行宇宙</td><td>科普读物，都有真实存在的理论支撑</td></tr><tr><td>暗淡蓝点</td><td>科幻概念比较多</td><td>对人性、宇宙、哲学的探讨</td></tr><tr><td>布洛卡的脑</td><td></td><td></td></tr><tr><td>指数型商机</td><td>对未来的猜测</td><td>刺激灵感</td></tr><tr><td>奇奇怪怪的生物们</td><td>介绍了110多种生物的能力</td><td>生物词典</td></tr><tr><td>跟动物交换身体</td><td></td><td></td></tr><tr><td>它们的性</td><td>影射人类社会</td><td></td></tr><tr><td>植物的战斗</td><td>生存能力强，与人类有关的植物</td><td>种田</td></tr><tr><td>哲学家都干了什么</td><td>科幻小说的核心都是在写人性与欲望，哲学家和诗人说的是最多的</td><td>哲学性</td></tr></tbody></table><h1 id="2-入门级书单"><a href="#2-入门级书单" class="headerlink" title="2. 入门级书单"></a>2. 入门级书单</h1><table><thead><tr><th>名称</th><th>特点</th><th>简介</th></tr></thead><tbody><tr><td>如何写好小说</td><td>适合故事主线</td><td>拆解目标、动机、矛盾的三大用法</td></tr><tr><td><a href="http://www.shzuojia.cn/zhuanti/wwxgc/down/2020Vol.05.pdf">爽感爆款系统</a></td><td>适合设计爽感</td><td>对斗破苍穹进行了拆解，写作逻辑</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>小说技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>书单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4如何提升小说文笔</title>
    <link href="/2024/08/17/2_4%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%B0%8F%E8%AF%B4%E6%96%87%E7%AC%94/"/>
    <url>/2024/08/17/2_4%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%B0%8F%E8%AF%B4%E6%96%87%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h1 id="小说基础文笔练习"><a href="#小说基础文笔练习" class="headerlink" title="小说基础文笔练习"></a>小说基础文笔练习</h1><h2 id="1-积累词汇"><a href="#1-积累词汇" class="headerlink" title="1. 积累词汇"></a>1. 积累词汇</h2><p>我们在描述一个物体的时候，需要用到一些词汇，其中可以把他们分成以下几种：<br><img src="/2024/08/17/2_4%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%B0%8F%E8%AF%B4%E6%96%87%E7%AC%94/%E8%AF%AD%E8%A8%80%E7%BB%84%E6%88%90.png" srcset="/img/loading.gif" lazyload alt="语言组成"></p><p>【一拳就打到我这个…..上巴！】</p><p>那我们练习的方式可以用这种：<br>空语 + 感语 + 名语，用语&#x2F;动语 + 感语 + 名语</p><p>例如：</p><blockquote><p>山谷中(<em>空</em>)幽暗的(<em>感</em>)走道(<em>名</em>)隐藏着(<em>用</em>)迷茫的(<em>感</em>)青春(<em>名</em>)</p></blockquote><p>就像这个句子，很多人说有文青病什么的，很多时候我们的语文都不超过小学五年级，根本轮不到我们有什么文青病，先练成文青，去掉病自然就很简单。</p><p>那么如何提升我们的文笔呢？盲目的机械化练习其实就和背英语单词一样，背了半天，走到街上和外国人说话，一句话都不会说，还不如我们直接从实战开始，去在日常生活中用词格逻辑描述大量的外部事物，这样久而久之就能积累大量的词汇。</p><p>以下是一些例子：</p><blockquote><p>小区里绿色的树飘落着泛黄的树叶。<br>她眼神中呆滞的瞳孔装着迷茫的梦<br>黑夜上闪耀的星河游离着空洞的繁星。</p></blockquote><p>这些看起来好像似乎具有文青病，但经过我们大量的练习加交叉使用下边讲到的画面感、比喻、拟人、夸张等等，久而久之就能够让自己的文笔更加舒服。</p><p>请现在描述一下你面前的桌子上都有哪些东西：</p><blockquote><p>主机旁黄色的台灯照亮了半边的显示器。手机静静地躺在支架上。B站上播放的视频扯碎了作者胡思乱想的梦。</p></blockquote><p>好，到此为止我们练习的都是单个的句子。</p><ol><li><strong>那么新人的文笔，重点应该提升在哪里呢？</strong></li></ol><p>很多人都会说文笔很重要，文笔不重要，文青病等等。文笔当然很重要，但我们重点提升的并不是一种情感的宣泄，一种我称之为古典的表述，这种表述极其强调隐喻、强调情感，但更加普世性的文笔其实应该是<code>感情真挚</code>、<code>语言简练</code>、<code>表达准确</code>，能够清晰的表达出作者的想法。</p><p>但是网文也有着属于他的特殊性，网文首先体裁特殊，他的校稿时间比较少，修改余地也比较小，并且门槛也非常低，很多作者并没有意识到自己的文笔底下，那我们首先要做到的只有四个字：<strong>言简意赅</strong></p><p>目标：少说废话，表达准确</p><ol start="2"><li><strong>文笔水平的上限又在哪里呢？</strong></li></ol><p>我们要知道的是，文笔水平的上限取决于文字审美的上限，如果你从小就是24史各种传统文学起手，那不用想，文笔自然高的一批，但是大部分看过的都是什么斗破苍穹、斗罗大陆这种小白文，那我们的文笔水平必然不会很高。</p><p>那有很多人就会问：我现在看传统文学还来得及吗？</p><p>如果你没有抱着目的性的去学习，或者有方法论的去学习，那我想告诉你的是，几乎不可能，等多图一乐呵，除非你愿意拿出每天学习十几个小时的热情来自己琢磨书中的话，否则很难仅凭个人能力，通过阅读传统书籍来提升文笔。</p><p>那我们如何提升自己的文字审美上限呢？</p><p>扫榜！带着目的性的去读你所在的领域中最热最牛的网文，不需要拆解剧情结构情绪什么的，只需要看他的文笔，描述，对于环境、画面感等等的描述。</p><ol start="3"><li><strong>如何长期有效的提高文笔？</strong></li></ol><p>我们的读者都是非常挑剔的，那我们要做的就是更加挑剔，不是去挑别人文章的毛病，而是根据别人预设的场景，自己写一段，自己来批判自己的那段文字，只有自己的眼光高了，才知道自己差在哪里。</p><p>保持3-6万字的稿子，等一周过后再去重新修改之前写过的文字，基本改过两遍之后文笔就会有显著的提升。但这并不是一两天就能达到的，往往是一个长期的工程。</p><p>除了网文之外，其实传统文学也是一个很好的阅读方向，就看各位作者有没有足够的时间，未来我阅读一些书籍和论文之后也会做成帖子分享给大家。</p><h2 id="2-灵感从哪里来？"><a href="#2-灵感从哪里来？" class="headerlink" title="2. 灵感从哪里来？"></a>2. 灵感从哪里来？</h2><p>刚开始写网文的时候，我们都觉得灵感是最值钱的东西，其实灵感往往是最不值钱的，灵感编织出的故事才会值钱。<br>下面我看了诸多UP主的推荐，给出大家一些这些书的建议。</p><ol><li><p><a href="https://z-lib.id/book/the-tv-writers-workbook">美剧编剧入行手册 英文原版（中文的可以买实体书）</a></p><blockquote><p>最重要的目标是积极的目标，而不是静态或者被动的。被动目标：主角不被仇敌抓到。主动目标：主角躲避仇敌追杀。<br>创作大纲时，用情绪动词代替情节，有助于情节发展：张三说翠花家务做的糟糕。改成：张三责怪翠花家务做的糟糕。</p></blockquote></li><li><p><a href="https://z-lib.id/book/the-science-of-writing-characters">人设心理学，可以在微信读书中看，同样找到的英文版</a></p></li><li><p><a href="">人性的博物馆：七堂小说写作课，微信读书有,没找到</a></p><blockquote><p>陌生化的小技巧：把熟悉的事物，通过陌生画的语言去描述出来，这样就会让读者产生新鲜感<br>例如心电感应：陌生化之后就可以写成心声读取系统、八卦系统、吃瓜系统、狗仔系统、爆料系统等等，还是同一个东西，但是换了个说法，就变得新颖很多。</p></blockquote></li><li><p><a href="">周末热炒店的编剧课</a></p><blockquote><p>我不教艺术，我也不关心艺术，我教的是一套完成一定质量作品的快捷方式</p></blockquote></li><li><p><a href="">10分钟编剧手册：聚沙成塔的剧本创作</a></p><blockquote><p>适合24K纯新手完全零基础的作者，像一本练习册</p></blockquote></li><li><p><a href="">畅销小说写作指南</a></p><blockquote><p>适合有完本小说的作者</p></blockquote></li><li><p><a href="">一路到夏天</a></p></li><li><p><a href="">志怪图鉴</a></p><blockquote><p>适合西幻、废土流的作者，图集，积累了各种怪物和传说</p></blockquote></li><li><p><a href="">解异集</a></p><blockquote><p>适合玄幻流，同样是图集，画风比较治愈</p></blockquote></li><li><p><a href="">ChatGPT写作超简单</a></p><blockquote><p>味大！无需多盐！</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>小说技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-小说爽点制造</title>
    <link href="/2024/08/17/2_3-%E5%B0%8F%E8%AF%B4%E7%88%BD%E7%82%B9%E5%88%B6%E9%80%A0/"/>
    <url>/2024/08/17/2_3-%E5%B0%8F%E8%AF%B4%E7%88%BD%E7%82%B9%E5%88%B6%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="如何制造爽点"><a href="#如何制造爽点" class="headerlink" title="如何制造爽点"></a>如何制造爽点</h1><p>我们写网文的时候一直在说情绪拉扯与爽点制造，但是究竟什么是爽点，什么又是情绪拉扯？在这篇文章中就由各位作者大大来和旺仔一起学习一下！</p><h2 id="1-拉扯不到位？"><a href="#1-拉扯不到位？" class="headerlink" title="1. 拉扯不到位？"></a>1. 拉扯不到位？</h2><p>假如主角有一个目标，这是一条直线，那我们就要在这条直线上做文章，产生波峰和波谷。</p><p>那如何构思情绪拉扯的剧情呢？</p><p>我们其实每个人都可以快速的构建一套最简单的框架，直接就现在草稿纸上把这条线先画出来：</p><p><img src="/2024/08/17/2_3-%E5%B0%8F%E8%AF%B4%E7%88%BD%E7%82%B9%E5%88%B6%E9%80%A0/%E6%83%85%E7%BB%AA%E6%8B%89%E6%89%AF%E6%A1%86%E6%9E%B6.png" srcset="/img/loading.gif" lazyload alt="情绪拉扯框架"></p><p>商业化的小说就是先射箭再画靶，就是需要由情绪波动来制造爽点，不管什么剧情都需要波动。</p><p>并且情绪波动可以三折，也可以五折，可以上行，同样也可以下行。<br><img src="/2024/08/17/2_3-%E5%B0%8F%E8%AF%B4%E7%88%BD%E7%82%B9%E5%88%B6%E9%80%A0/%E6%83%85%E7%BB%AA%E8%B5%B0%E5%90%91%E6%8A%98%E7%BA%BF.png" srcset="/img/loading.gif" lazyload alt="情绪走向折线"></p><p>情绪折线里具体的情绪有非常多，例如喜悦、激动、悲伤、绝望等等，但我们要记得的是，相邻的上下情绪点一定要带来截然相反的情绪感受，积极的在上边，消极在下方。</p><p>到现在为止，都是十分简单的。</p><p>那真正难的地方在哪里？难的地方在于写出合适的剧情！</p><p>那么我们该如何构思一个合理的逻辑剧情呢？人物和事件的发展又该是什么样子的呢？</p><p>我们可以用以下这套逻辑框架，注意我这里强调的是思考逻辑顺序，而不是只看结果。</p><p>以下是一个实例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">主角身份：退役兵王  金手指：枪法好<br>主线剧情：主角开船护送一批菜鸟去往目的地<span class="hljs-selector-tag">A</span><br>可能反派：土匪<br></code></pre></td></tr></table></figure><p><strong>扑街写法1</strong>：主角–开船–到达目的地，毫无波澜<br><strong>根据金手指来写</strong>：（扮猪吃虎）</p><p>一般很少使用三折，大部分都是五折甚至七折，也就是俗称虚晃一枪。<br><img src="/2024/08/17/2_3-%E5%B0%8F%E8%AF%B4%E7%88%BD%E7%82%B9%E5%88%B6%E9%80%A0/%E7%BB%8F%E5%85%B8%E4%BA%94%E6%8A%98%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="经典五折图"></p><p>一般第一个上升是虚晃一枪，根据第二个的波峰来设计第一个波峰。</p><p>我们需要不断地以马后炮的思维来复盘，构建一整套思维逻辑，而不只是单纯地照搬剧情。</p><h2 id="2-爽点是什么？"><a href="#2-爽点是什么？" class="headerlink" title="2. 爽点是什么？"></a>2. 爽点是什么？</h2><p>是装逼打脸吗？是泡妹子吗？本质其实是一种<strong>对比</strong>，为什么会觉得有的人的小说，同样的剧情，他写的就超级爽，但是另一部分人写的就平平无奇。</p><p>例如，我每天的零花钱是10块，这样写看起来平平无奇，因为大家的零花钱都至少是这个数。</p><p>但如果我现在写：只有我每天的零花钱是10块，其他人每天的零花钱都只有1分钱，甚至班里最有钱的土豪也只有1毛，这样显得我的10块钱就巨牛逼，就建立了1分钱和10块钱的对比。</p><p>同样，什么是幸福？幸福也是对比。</p><h2 id="3-如何设计情节转折，转折是剧情反转吗？"><a href="#3-如何设计情节转折，转折是剧情反转吗？" class="headerlink" title="3. 如何设计情节转折，转折是剧情反转吗？"></a>3. 如何设计情节转折，转折是剧情反转吗？</h2><p>首先我们要意识到的一点是转折并不等于反转，并不是一个故事反过来写就是一个好故事，转折实际上是故事的一种发展变化，可以是逐渐的，预期的，同样也可以是突然的，出人意料的。反转更强调意外性和戏剧性变化，与读者预期相悖。</p><p>情节转折简单来说有3步：</p><ol><li>基本事件：主角要干一件大事</li><li>冲突事件：干的过程中遇到了阻碍</li><li>事件结果：本来3年干成，结果画了10年</li></ol><p>明确了情节转折的这三步之后，那我们再掌握一下10种情节转折的方法：</p><ol><li>引入新角色、新物品改变故事的发展</li><li>时间跨度（前期主角心高气傲，后期以新的姿态面对）</li><li>利用冲突（故事的核心元素，加深现有冲突，或者引入新的冲突，角色之间的矛盾，价值观的碰撞）</li><li>合理的利用巧合（双线，明线+暗线，但是不能过度依赖）</li><li>人物做出错误的决策，引发一系列后果（误会导向）</li><li>制造意外，打破原来的轨迹</li><li>利用反转（主打的就是颠覆，一直认为是受害者的角色，实际上是幕后黑手）</li><li>隐藏信息</li><li>换地图</li><li>改变人物目标或者动机（变化可以是成长，也可以是颓废）</li></ol><p>除了情节之外，还有人物关系，人物性格、价值观、环境、情感等等。重大转折一两次就好，太多容易疲劳。</p><h2 id="4-如何使用供需法设计剧情"><a href="#4-如何使用供需法设计剧情" class="headerlink" title="4. 如何使用供需法设计剧情"></a>4. 如何使用供需法设计剧情</h2><p><strong>供需法</strong>：主角供给，配角需求；或者配角供给，主角需求。</p><p>例子：主角去吃饭，去菜市场买菜，然后回来做饭开吃。（X）<br>A遇到困难，菜卖不出去，要坏了，很急很急。（先提出A的剧情）<br>一句话带过B有这么个需求或者供给。</p><p>因为主角要亏钱，想到了一个增加用工成本的好办法，要开始招聘计划。</p><ul><li>low写法：主角牛逼了，发钱了，招聘了，好厉害啊！员工好激动啊！我上班啦！</li><li>供需法：在主角有一个招聘想法之后，有一个需求方（为什么有这个需求方？）（解决大量的老百姓(残障人士–逻辑严谨)就业问题），但是苦于遇到困难，没有企业招人！</li></ul><p><strong>要点</strong>：目的+困难+解决方案<br>目的：主角的目的<br>困难：配角的困难</p><p>主角的目的 &#x3D; 配角的需求 (二者之间有强大的困难)<br>配角的需求几乎很难实现(几乎是配角的个人幻想)</p><ol><li>玄幻文：主角目的：杀个大帝玩玩<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">扑街：主角出门闲逛，遇到一个老人，因为一点小事情直接开喷，老人很嚣张，主角直接把对方拍死，吃瓜群众震惊。<br>供需：大帝要杀戮女配的全族，或者怎么怎么作死<br>困难：大帝很强大<br></code></pre></td></tr></table></figure></li></ol><p>一般这种写法可以写个3-5章</p><p>提升矛盾，开篇制造配角的危机，让主角解决矛盾。<br>直接切入剧情。<br>某战场，战斗十分激烈，我方即将战败。<br>我方将士为了掩护老百姓安全转移，面对数十倍拥有优势装备的敌军，死守阵地。<br>在所有将士奋力抵抗的时候，此时有一名年轻的战士似乎正在发呆(一笔带过主角，不要过多描述，后续再铺垫)</p><p>小八嘎即将攻破阵地，我方战士开始绝望，部分老百姓也面露绝望。</p><p>之后切换主角画面，刚意识过来，此时就已经有冲突。</p><p>第二章再写设定，第一张刚把金手指露出来就结束。</p><p>高潮：群体性的配角需求都遇到了困难。</p><p>加上信息差，主角和配角的信息获取程度不一致，一般都是配角在前，主角在后，但是阴差阳错。如果是重生文，就反过来。</p><h2 id="附件I-参考文献"><a href="#附件I-参考文献" class="headerlink" title="附件I 参考文献"></a>附件I 参考文献</h2><ol><li><p><a href="https://www.bilibili.com/video/BV1SB4y1U7nY/?spm_id_from=333.999.0.0&vd_source=98101c1de7471be746ee7086e136f38f">B站UP主宝剑侍从视频：网文的“情绪拉扯”与“爽点制造”如何搞定？</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1Ym411S7dM/?p=18&spm_id_from=pageDriver">B站UP主尘三昧视频：情节转折3个步骤，10个方法，让故事更加扣人心弦</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小说技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爽点制造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存算一体</title>
    <link href="/2024/08/17/1_2-%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93/"/>
    <url>/2024/08/17/1_2-%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="存算一体"><a href="#存算一体" class="headerlink" title="存算一体"></a>存算一体</h1><h2 id="1-存算一体的概念"><a href="#1-存算一体的概念" class="headerlink" title="1. 存算一体的概念"></a>1. 存算一体的概念</h2><p>除了FPGA，存算一体是一个很新的非冯诺依曼架构，那我们该从哪里开始去看存算一体，或者从哪个地方入门，这篇博客对经典的存算一体进行了汇总。</p><p>首先我们要了解什么是存算一体(Computing in Memory)。</p><p>存算一体的名称，分类在业界没有统一，不同的人有不同的叫法，英文名称也不统一</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">Processing</span>-<span class="hljs-variable"><span class="hljs-keyword">in</span></span>-<span class="hljs-function"><span class="hljs-title">memory</span>(<span class="hljs-variable">PIM</span>)</span><br><span class="hljs-variable">Computing</span>-<span class="hljs-variable"><span class="hljs-keyword">in</span></span>-<span class="hljs-function"><span class="hljs-title">memory</span>(<span class="hljs-variable">CIM</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">In</span></span>-<span class="hljs-variable">memory</span> <span class="hljs-function"><span class="hljs-title">processing</span>(<span class="hljs-variable">IMP</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">In</span></span>-<span class="hljs-variable">memory</span> <span class="hljs-function"><span class="hljs-title">computing</span>(<span class="hljs-variable">IMC</span>)</span><br><span class="hljs-variable">Logic</span>-<span class="hljs-variable"><span class="hljs-keyword">in</span></span>-<span class="hljs-function"><span class="hljs-title">memory</span>(<span class="hljs-variable">LIM</span>)</span><br><span class="hljs-variable">Near</span>-<span class="hljs-variable">data</span> <span class="hljs-function"><span class="hljs-title">computing</span>(<span class="hljs-variable">NDC</span>)</span><br><span class="hljs-variable">Near</span>-<span class="hljs-variable">data</span> <span class="hljs-function"><span class="hljs-title">processing</span>(<span class="hljs-variable">NDP</span>)</span><br><span class="hljs-variable">Near</span>-<span class="hljs-variable">memory</span> <span class="hljs-function"><span class="hljs-title">computing</span>(<span class="hljs-variable">NMC</span>)</span><br><span class="hljs-variable">Near</span>-<span class="hljs-variable">memory</span> <span class="hljs-function"><span class="hljs-title">processing</span>(<span class="hljs-variable">NMP</span>)</span><br></code></pre></td></tr></table></figure><ol><li><p><strong>近存计算PNM</strong><br>近存计算，本质上仍然是存算分离架构，计算操作仍然由独立的计算单元完成。只不过该架构能够通过存储上移或者计算的方式，让数据更加接近计算单元，从而缩小数据移动的延迟和功耗。<strong>特斯拉、达摩院、三星</strong>等选择的便是近存计算。</p></li><li><p><strong>存内处理PIM</strong><br>存内处理，本质上仍然是存算分离，不过相较于近存计算，存和算的距离更近，计算单元内嵌于存储芯片内，但是他们还是各干个的。国内<strong>知存科技</strong>选择的便是存内处理。</p></li><li><p><strong>存内计算CIM</strong><br>存内计算是真正的狭义上的存算一体，在这个框架下，存储和计算完全融合，没有独立的计算单元，直接在存储器颗粒上嵌入算法，由存储器芯片内部的存储单元完成计算操作。这也是大部分初创公司所说的存算一体。</p></li></ol><p>经过研究发现，大公司和初创公司的思路为：传统芯片大厂几乎都在布局PNM；而初创公司都在押注PIM。</p><p>存算一体是在存储器中嵌入计算能力，用新的运算架构来进行二维和三维矩阵乘法&#x2F;加法运算。存算一体这一技术概念，最早可以追溯到上个世纪70年代，近几年随着云计算和AI的迅速发展，面对各种数据洪流，数据迁移成为了一个非常大的问题，也就是IO瓶颈。</p><p>计算性能的提升速率远高于内存性能的提升，结果长期下来，存储速度严重滞后于运算速度，因此我们发明了各种软硬件方法来提升IO速率，例如缓存，又分为二级缓存，三级缓存等等。</p><p>在传统的冯诺依曼架构中，存储是为计算服务的，因此会天然的把运算和存储进行分离。但是如今存储和计算不得不一起考虑。</p><p>以下这篇博客希望大家可以看一下，里边讲了很多存算一体的基本概念：</p><ul><li><a href="https://www.eet-china.com/mp/a195588.html">1.存算一体的发展史、优势、应用方向、主要介质</a></li><li><a href="https://people.inf.ethz.ch/omutlu/pub/onur-Dagstuhl-PIM-Security-28-November-2023.pdf">2.PIM基本扫盲</a></li></ul><p>存算一体是一种以数据为中心的计算模式，数据在哪，计算就在哪。<br><strong>相比较冯诺依曼架构的优势</strong>：</p><ul><li>缩短访存路径，降低仿存延迟</li><li>缩短访存路径，降低访存能耗</li><li>存储器内部访存带宽高</li><li>在存储阵列上原位执行计算，并行度高</li></ul><h2 id="2-忆阻器的概念"><a href="#2-忆阻器的概念" class="headerlink" title="2. 忆阻器的概念"></a>2. 忆阻器的概念</h2><p>忆阻器便是在存算一体中的一个重要器件，1971年美籍华人蔡少棠在论文中预言了忆阻器的存在。<br><img src="/2024/08/17/1_2-%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93/%E5%BF%86%E9%98%BB%E5%99%A8%E7%9A%84%E9%A2%84%E8%A8%80.png" srcset="/img/loading.gif" lazyload alt="忆阻器的预言"></p><p>在电路中有四个基本变量，电流、电压、电荷、磁通量，他们之间的关系构成了基本无源电路元件：电阻、电感、电容。但是在四个象限中还少一个，论文中预言了这种元器件的存在，并且设想了这种元件给电路带来很多有趣的特性，被命名为忆阻器(memristor -&gt; memory resistor)。</p><p>2008年惠普的科学家第一次制造出了这种元件。<br><img src="/2024/08/17/1_2-%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93/%E5%BF%86%E9%98%BB%E5%99%A8%E7%9A%84%E5%88%B6%E9%80%A0.png" srcset="/img/loading.gif" lazyload alt="忆阻器的制造"></p><p>忆阻器最初是由一片双层的二氧化钛薄膜所成，当电流流过时，其电阻值就会发生改变。<br><img src="/2024/08/17/1_2-%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93/%E5%BF%86%E9%98%BB%E5%99%A8%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="忆阻器结构"></p><p>理想的人工突触器件应该具有以下性质：</p><blockquote><p>具有非易失的突触权重<br>具有突触可塑性<br>突触权重能够通过学习从而发生改变<br>纳米级尺寸<br>低功耗、高并行<br>易于大规模互连集成。<br>忆阻器满足了上述的所有条件。</p></blockquote><p>AI中存在着大量的矩阵运算，例如矩阵乘以向量。<br><img src="/2024/08/17/1_2-%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97.png" srcset="/img/loading.gif" lazyload alt="矩阵运算"></p><p>传统的思路是，每一个节点都需要运算器来计算一遍，那么忆阻器是如何实现的呢？<br><img src="/2024/08/17/1_2-%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93/%E5%BF%86%E9%98%BB%E5%99%A8%E8%BF%90%E7%AE%97%E6%96%B9%E5%BC%8F.png" srcset="/img/loading.gif" lazyload alt="忆阻器运算方式"><br>根据基尔霍夫定律做加法，基于欧姆定律做乘法，每一个节点的电流可以直接进行相加，之后在横向的一侧进行测量，便可以直接得到运算结果。</p><p>我们相当于一次性就可以完成这个矩阵乘以向量的计算，效率大大的。</p><p>那么现在我们想，这个模型会遇到什么问题？</p><blockquote><ol><li>计算数值非常大？</li><li>矩阵本身非常大？</li><li>模拟计算本身的误差该如何消除？<br>…</li></ol></blockquote><p>2017年，清华吴华强团队用一个128*8的阵列实现了人脸识别，追求的是系统的准确率，而不是单个器件的准确率。<br><img src="/2024/08/17/1_2-%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93/%E5%90%B4%E5%8D%8E%E5%BC%BA%E5%9B%A2%E9%98%9F%E8%AE%BA%E6%96%87.png" srcset="/img/loading.gif" lazyload alt="吴华强团队论文"></p><p>在参考1中讲到了<strong>忆阻器件的发展</strong>、<strong>忆阻器阵列存算一体演示</strong>等等，推荐大家去观看。</p><p>参考资料：</p><ol><li><a href="https://www.bilibili.com/video/BV1LG411H7is/?buvid=XX3C9BA3386CD802BC14CED078E9A0D60F26D&from_spmid=main.my-history.0.0&is_story_h5=false&mid=pMgQaVLqvEPCkFqgoxvUgg==&p=1&plat_id=116&share_from=ugc&share_medium=android&share_plat=android&share_session_id=32ff03b9-661b-465b-b665-741105e93b92&share_source=WEIXIN&share_tag=s_i&spmid=united.player-video-detail.0.0&timestamp=1724726791&unique_k=VPj9rFt&up_id=4299350&vd_source=98101c1de7471be746ee7086e136f38f">B站：基于忆阻器的存算一体架构</a></li><li><a href="https://www.bilibili.com/video/BV1nN411g7HC/?spm_id_from=333.337.search-card.all.click">B站：忆阻器芯片到底是什么？</a></li></ol><h2 id="3-存算一体分类"><a href="#3-存算一体分类" class="headerlink" title="3. 存算一体分类"></a>3. 存算一体分类</h2><p>目前，存算一体的技术路径尚未形成统一的分类，目前主流的划分方法是依照计算单元与存储单元的距离，将其大致分为</p><ol><li>近存计算（PNM）</li><li>存内处理（PIM）</li><li>存内计算（CIM）。</li></ol><p><strong>近存计算</strong> 是一种较为成熟的技术路径。它利用先进的封装技术，将计算逻辑芯片和存储器封装到一起，通过减少内存和处理单元之间的路径，实现高I&#x2F;O密度，进而实现高内存带宽以及较低的访问开销。近存计算主要通过2.5D、3D堆叠等技术来实现，广泛应用于各类CPU和GPU上。 </p><p><strong>存内处理</strong> 则主要侧重于将计算过程尽可能地嵌入到存储器内部。这种实现方式旨在减少处理器访问存储器的频率，因为大部分计算已经在存储器内部完成。这种设计有助于消除冯·诺依曼瓶颈带来的问题，提高数据处理速度和效率。 </p><p><strong>存内计算</strong> 同样是将计算和存储合二为一的技术。它有两种主要思路。第一种思路是通过电路革新，让存储器本身就具有计算能力。这通常需要对SRAM或者MRAM等存储器进行改动，以在数据读出的decoder等地方实现计算功能。这种方法的能效比通常较高，但计算精度可能受限。 </p><p>另一种思路是在存储器内部集成额外的计算单元，以支持高精度计算。这种思路主要针对DRAM等主处理器访问开销大的存储器，但DRAM工艺对计算逻辑电路不太友好，因此集成计算单元的挑战较大。 </p><p>目前存内计算的方式较为单一，多数集中在利用非易失性存储阵列（忆阻器）实现原位的信号模拟矩阵向量乘。同样也可以用于易失性存储器（SRAM）和数字模式存内计算。</p><h2 id="4-存算一体论文阅读心得"><a href="#4-存算一体论文阅读心得" class="headerlink" title="4. 存算一体论文阅读心得"></a>4. 存算一体论文阅读心得</h2><p><a href="https://doublesevenshop.github.io/2024/08/26/1-5-%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93%E7%BB%8F%E5%85%B8%E6%96%87%E7%AB%A0%E7%B2%BE%E8%AF%BB/">文章精读系列</a></p>]]></content>
    
    
    <categories>
      
      <category>论文系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存算一体</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-小说扫榜</title>
    <link href="/2024/08/15/2_2-%E5%B0%8F%E8%AF%B4%E6%89%AB%E6%A6%9C/"/>
    <url>/2024/08/15/2_2-%E5%B0%8F%E8%AF%B4%E6%89%AB%E6%A6%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="小说扫榜"><a href="#小说扫榜" class="headerlink" title="小说扫榜"></a>小说扫榜</h1><h2 id="1-在哪个地方扫榜？"><a href="#1-在哪个地方扫榜？" class="headerlink" title="1. 在哪个地方扫榜？"></a>1. 在哪个地方扫榜？</h2><p>在学习写作网文之前，有一件很重要的事情便是——扫榜。</p><p>我们得首先知道目前最火的书大概都在写哪些内容，把握市场的风向，才能基本不扑街。</p><p>我目前是在番茄写书，并且经常会在网页端查看，那我们就可以点击番茄主页的原创榜<br><img src="/2024/08/15/2_2-%E5%B0%8F%E8%AF%B4%E6%89%AB%E6%A6%9C/%E7%95%AA%E8%8C%84%E5%B0%8F%E8%AF%B4%E4%B8%BB%E9%A1%B5.png" srcset="/img/loading.gif" lazyload alt="番茄小说主页"></p><p>我们可以看到原创榜里边有<code>阅读榜</code>和<code>新书榜</code>，一般来讲我会更多的看一些新书榜，并且同时看一下在读和更新篇章。一般在读很多，但是篇章很少的，说明这本书大概率有非常闪光的点。</p><p>尽量要拆半年以内的好书，这样会更加有时效性，不要去拆好几年前的书，写作的方式和方法可能都有些过时。例如里边的一些陈年老梗，现在可能不再使用（小黑子除外）。</p><p>我们接下来要做的就是认认真真的扒一下这几本书。</p><h2 id="2-怎么扒书"><a href="#2-怎么扒书" class="headerlink" title="2. 怎么扒书"></a>2. 怎么扒书</h2><p>在看书之前，我们可以简单的看一下他们的目录风格，很多作者的书，他们的目录就非常的有梗。但是这个是需要一定的实力的，有的人就是会为了一碟醋包一盘饺子。<br><img src="/2024/08/15/2_2-%E5%B0%8F%E8%AF%B4%E6%89%AB%E6%A6%9C/%E7%95%AA%E8%8C%84%E5%B0%8F%E8%AF%B4%E7%9B%AE%E5%BD%95.png" srcset="/img/loading.gif" lazyload alt="番茄小说目录"></p><p>很明显这个作者的目录标题都比较长，很有可能他会从文章的某一句中摘出来，当做目录，那么我们大致扫一眼目录，基本就能看出整本书的故事发展曲线。</p><p>除此之外，我们也可以关注每一章的99+的评论，一般这些评论都具有作者明显的笔风或者文风，读者可以帮我们说出这个地方“好”的原因。</p><p>在文章中，我们必须要找到的是，<code>引起读者共鸣的话</code>， <code>驱动主角的原因</code>，<code>主角和整个世界的联系</code>，<code>埋的伏笔，以及伏笔间隔</code>，<code>期待感的由来</code>。</p><p>其实还有很多很多，最关键的是我们一定要带着审视与思考来读一篇文章，不再把它当成一篇爽文。</p><p>这一点本人深受其害啊，之前无脑刷榜，结果看着看着就几百章过去了，结果也没什么收获…..</p><p>我看一个UP主学到的方法是，大家可以尝试用嘴巴读出小说，在每一句中都会无意间加入自己的思考，这样会效率高很多。</p><p>还有就是大家在扫榜之前，可以去看一下作者的粉丝以及写的书的类型，这样会对这个作者的水平大致心里有一个数。</p><p>每天大概扫1本书的前10章就可以，也就是前2万字，如果这2万字你感觉写的非常流畅，非常爽，那我们可以进一步思考一下作者的大纲是怎么写的，以及如果是你的话，你认为未来的方向会怎么发展，同时对前10章出现的人物描写，可以做进一步解读。</p><p>在扫榜的过程中，一定要注意人设以及剧情，其实文笔是不怎么重要的，大家完完全全临摹两三本书的前10章基本就心里有数了！</p><h2 id="3-拆书之后该干嘛？"><a href="#3-拆书之后该干嘛？" class="headerlink" title="3. 拆书之后该干嘛？"></a>3. 拆书之后该干嘛？</h2><p>新手小白，包括我在内，很多时候都记不住我们看过的内容，从扫榜拆书，到完成大纲，到落笔，再到投稿签约。</p><p>我们会发现第一步就把我们钉死了。</p><p>很多时候我们在扫榜的时候脑袋划过很多灵感，但是一下笔却什么都想不起来，那么该怎么破呢？</p><p>首先我们可以用Excel或者Word，或者Markdown来把他的大致内容记录下来，这样即使过了很久，我们也能做到心里有数。<br><img src="/2024/08/15/2_2-%E5%B0%8F%E8%AF%B4%E6%89%AB%E6%A6%9C/Excel%E8%AE%B0%E5%BD%95.png" srcset="/img/loading.gif" lazyload alt="Excel记录故事"></p><p>那么在记录之后，我们可以仿着他的前期大纲，然后逐步改一下人物设定，再到背景设定，再到剧情发展，我们可以逐步仿写，进而把所有的内容都替换。</p><p>在仿写的时候我们也要注意，如何营造期待感和爽点，这个是十分重要的，一定要在仿写的过程中思考。</p><p>那么之后我也会针对我拆的书进行一个仿写，也是对我自己的一个鞭策。，发在<strong>扫榜系列</strong>过程中。</p><p>在拆书过程中一定要记录下来是如何营造笑点和爽点的，同时一定要做<strong>写作技巧</strong>总结，这是我们拆书最最重要的一部分。</p><p>在拆书过程中，尤其是针对主线剧情，一定要知道“情之所起”，也就是说我们得知道这个剧情，这个读者的情感，文中角色的情感是从哪个地方出来的，以及未来是怎么发展的，要不然就会转折非常非常生硬。读者就可能不太会关心主角或者配角的发展。</p><p>个人扫榜心得：</p><blockquote><p>首先我们要对人感兴趣，在写书或者练习书的过程中，写到哪个角色，哪个角色其实就是主角，要站在这个角色的角度来思考，而不是一味地站在主角的角度思考。</p></blockquote><p>都市异能、都市高武和传统玄幻都比较难写，我目前写过四五个开头，这三个都有涉猎，我发现对于这三个题材来说，他天然的世界框架比较大，并且需要一种极强的代入感，会将普通人和特殊人之间存在一种天然的阶级差距，并且需要设定规则来规训特殊人，这些都是比较需要铺很多设定。</p><p>因此我个人目前的重点在于都市日常。</p><h2 id="4-拆书角色与主题的方法"><a href="#4-拆书角色与主题的方法" class="headerlink" title="4. 拆书角色与主题的方法"></a>4. 拆书角色与主题的方法</h2><ol><li>选书：故事线完整+剧情张弛有度+人物性格鲜明</li><li>故事梗概：故事背景、主要人物、故事情节</li><li>主线剧情分析：<ul><li>开篇：故事起始事件（场景+人物+事件），引发冲突的主要问题</li><li>铺垫：高潮之前的重点情节，如何引起读者注意力</li><li>高潮：如何解决主要冲突，重大决策上如何做出选择，重大转折点在哪，最紧张的部分是怎么写的？</li><li>结尾：故事最终结果，人物命运走向，给读者留下印象深刻的点</li></ul></li><li>支线剧情分析：<ul><li>支线1：比较支线剧情和主线剧情的差异和相似之处</li><li>支线2：同上</li></ul></li><li>角色分析：<ul><li>主角：分析性格（根据相关情节）、如何推动故事发展，如何面对挑战，克服困难以及思想上的升华&#x3D;性格+目标动机+成长转变</li><li>配角：与主角的关系，互动方式，性格行为，对情节的影响</li><li>反派：人物背景（出身、学识、经历等）；与其他角色之间的冲突，如何影响故事发展的成长，变化，最终结局&#x3D;人物背景+角色冲突+人物弧线</li></ul></li><li>主题与情感分析：<ul><li>主题：爱、人性、战争、成长、友谊、正义、勇气等等</li><li>情感表达：角色之间的纽带和变化</li></ul></li><li>写作风格与技巧：<ul><li>风格：属性（独一无二）<ol><li>叙事风格：视角（第一人称、第三人称有限&#x2F;全知）、节奏、高潮和低谷的分布</li><li>叙事技巧：倒叙、插叙</li><li>人物刻画：外貌、语言、行为、心理</li><li>情节构建：悬念、伏笔、意外、转折</li></ol></li><li>技巧：装备（更具表现力）</li></ul></li><li>个人感悟与评价：<ul><li>个人感悟：对情节、人物、主题的理解</li><li>总结优点：有哪些引人入胜的情节、深刻的角色</li><li>不足之处：尝试找错，刻意找漏洞，角色行为不合理的地方</li></ul></li></ol><h2 id="5-拆书结构的方法"><a href="#5-拆书结构的方法" class="headerlink" title="5. 拆书结构的方法"></a>5. 拆书结构的方法</h2><p>首先一定要挑你想写的类型，并且自己能够看得下去，而且必须成绩要好，这三个成绩必须达成。</p><p>我拆了一本主角比较怂的书，但是我写的又是一个大BOSS，就导致我自己写出来的那个人设比较拧巴。</p><p><strong>拆开头是为了什么</strong>：学铺设定、学塑造角色、学情节框架</p><p><strong>如何拆书的结构</strong>：填表格！</p><ol><li>先以读者视角阅读一遍文章</li><li>填写章节名称、内容简介、剧情进展、涉及人物</li></ol><p><img src="/2024/08/15/2_2-%E5%B0%8F%E8%AF%B4%E6%89%AB%E6%A6%9C/%E6%8B%86%E4%B9%A6%E7%BB%93%E6%9E%84%E8%A1%A8%E6%A0%BC.png" srcset="/img/loading.gif" lazyload alt="拆书结构表格"></p><ol start="3"><li>重新逐章阅读并分类，例如第一幕1-20章，第二幕21-30章，并且标注出高潮是哪些（正方、反方、小弟等）</li><li>进行总结<ol><li>爽点章节占整卷的比例（可以标注，至少一半以上是爽点）</li><li>期待感占整卷的比例（同样标注）</li><li>涉及的铺垫（从上一卷的次要矛盾变成这一卷的主要矛盾）</li><li>各种人物出场安排（在非爽点情节中轮番出席，触发剧情，在爽点情节中集中出现）</li><li>冲突的升级、反击、化解等等</li></ol></li></ol><h2 id="附件I-个人小说拆书Excel"><a href="#附件I-个人小说拆书Excel" class="headerlink" title="附件I 个人小说拆书Excel"></a>附件I 个人小说拆书Excel</h2><p>下面是我个人拆书的一些记录，也算是我个人的一个成长记录。</p><ul><li><a href="https://www.yuque.com/wangzi-kefxg/mndxbi/lyk1m008pxvox9lb/edit#O6CR">番茄 得知自己是替身，合约妻子哭惨了</a>（这一篇其实人物塑造的比较一般，评分也有些低，但是看的人非常多，目前在新书榜第一，只拆了前六章，这本书让我拆的十分难受）</li></ul><h2 id="附件II-参考文献"><a href="#附件II-参考文献" class="headerlink" title="附件II 参考文献"></a>附件II 参考文献</h2><ol><li><p><a href="https://www.bilibili.com/video/BV1w34y1d73E/?spm_id_from=333.337.search-card.all.click">B站UP主宝剑侍从视频：怎么拆书看剧情结构</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1fJ4m1e7iB/?spm_id_from=333.337.search-card.all.click">B站UP主尘三昧视频：8步拆爆文</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小说技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>扫榜</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-用Chisel设计CPU各模块</title>
    <link href="/2024/08/15/1_1-%E7%94%A8Chisel%E8%AE%BE%E8%AE%A1CPU%E5%90%84%E6%A8%A1%E5%9D%97/"/>
    <url>/2024/08/15/1_1-%E7%94%A8Chisel%E8%AE%BE%E8%AE%A1CPU%E5%90%84%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="序章：需求分析"><a href="#序章：需求分析" class="headerlink" title="序章：需求分析"></a>序章：需求分析</h1><p>首先，我们要做的是用chisel设计一个单周期的RISC-V处理器，那么到底该从哪个地方来入手呢？</p><p>我们可以先简单的做一下需求分析。</p><p>对于RISC-V来说，它有一套固定的指令集规范，也就是软件和硬件交互的接口，我们设计的处理器，就是在ISA规范的基础上进行CPU各个模块的设计。</p><p>那么ISA到底到底是什么呢？</p><p>在之前的博客中我们已经提到，ISA包括特权指令集和非特权指令集。在我们这个项目中，我们并不需要完整的把所有的指令集的实现出来，实际上我们只需要支持最基本的指令集，便可以完成我们单周期的实现。我们考虑将<code>RV32I</code>作为我们的基本项目指令集，同时加入<code>A扩展</code>便基本可以支持操作系统。</p><p>OK，那到现在在指令集方面我们便已经了解到，想要开始一个单周期处理器，我们目前只需要实现RV32I即可！</p><p>那关于体系结构，我们在CPU设计中主要有两部分内容：<strong>数据通路+逻辑控制</strong></p><p>在体系结构这门课中，我们学到过许多现代处理器常见的技术，例如Cache、流水线、分支预测、SIMD等等，但我们是单周期啊！</p><p>从内存方面来说，我们直接访问硬件内存和数据，根本不用Cache；从指令集并行来说，咱们单周期，并行这个概念还没有诞生；从数据级并行来说，我们也没有支持向量扩展，跳过；线程级并行来说，目前我们用的还是单核，不存在多线程以及共享内存之类的，包括虚拟地址转换等等高级的功能，我们都可以不涉及到。</p><p>同时各种优化技术一律抛弃，只需要实现一个最简单的单周期RISC-V处理器即可！</p><h1 id="第一幕：初步设计"><a href="#第一幕：初步设计" class="headerlink" title="第一幕：初步设计"></a>第一幕：初步设计</h1><p>在了解到我们的需求之后，我们还不能闷头狂干，首先得想一下我们都需要哪些工具呢？</p><p>对于指令集来说，RV32I有6种类型的指令集，具体内容可以看这个帖子<a href="https://blog.csdn.net/qq_57502075/article/details/132015845">RISC-V指令集介绍</a></p><p>RV32I是基本的32位整数ISA，只有47条指令，具体可以看这个博客<a href="https://www.sunnychen.top/archives/riscvbasic">RISC-V基本指令集概述</a></p><p>除了ECALL和EBREAK之外，大部分指令集都比较规整，根据这些指令集，我们可以分为：</p><ul><li>跳转类：JAL、JALR</li><li>条件分支类：BEQ、BNE、BLT、BGE、BLTU、BGEU</li><li>加载&#x2F;存储类：LB、LH、LW、LBU、LHU、SB、SH、SW</li><li>算数逻辑和位运算：addi等</li><li>比较指令类：SLTI、SLTIU、SLT、SLTU</li><li>其他指令：FENCE、ECALL、EBREAK</li></ul><p>根据上边这些指令，我们可以设计出CPU至少应该包含以下组件：</p><ol><li><strong>指令内存MemInst</strong>：接受一个32位指令地址，读取出指令</li><li><strong>PC寄存器PCReg</strong>：为指令内存提供指令地址，每个时钟周期自增4，当前指令为跳转时，下一条指令为跳转目的的地址；分支预测成功时，下一条指令为分支目标地址</li><li><strong>通用寄存器堆Register</strong>：可读可写的寄存器，接受寄存器号，为运算单元提供操作数，接受运算结果，或者从数据内存读取到的值。</li><li><strong>数据内存MemData</strong>：根据加载&#x2F;存储地址，加载或存储数据，加载或存储依赖于译码器的译码</li><li><strong>指令译码器Decoder</strong>：对指令进行译码，解析得到的立即数、操作码、寄存器号等信息</li><li><strong>运算单元ALU</strong>：根据操作数和操作码进行运算，运算结果写到寄存器，分支指令时将比较结果发送给PC，加载存储指令时计算地址。</li></ol><p>上边我们只描述到了数据通路，那如果想要CPU正常运行，还需要逻辑控制。逻辑控制需要根据译码结果对数据通路进行控制：</p><ol><li><strong>ctrlJump</strong>：指令是否为跳转指令 if是，需要给控制信号到PC，要求在下一个时钟周期修改跳转目的地址</li><li><strong>ctrlBranch</strong>：指令是否为分支指令，if是，根据运算单元的比较结果，决定是否让PC在下一个时钟周期修改为分支目标地址</li><li><strong>ctrlRegWrite</strong>：指令是否需要写寄存器，if是，将运算单元的结果&#x2F;数据内存中读取的值写到寄存器</li><li><strong>ctrlLoad</strong>：指令是否为加载指令，if是，写入寄存器的值的来源是数据内存</li><li><strong>ctrlStore</strong>：指令是否为存储指令，if是，将寄存器中的值写入到数据内存中</li><li><strong>ctrlALUSrc</strong>：指令的操作数是立即数还是寄存器值，根据这个状态来选择操作数的值</li><li><strong>ctrlJAL</strong>：指令是否为JAL指令。if是，操作数1的值应当为PC寄存器的值</li><li><strong>ctrlOP</strong>：为ALU确定具体的操作。</li></ol><p>这些控制信号的生成和传输统一有控制器来完成。</p><p>我们可以根据此设计一个初步的草图：</p><p><img src="/2024/08/15/1_1-%E7%94%A8Chisel%E8%AE%BE%E8%AE%A1CPU%E5%90%84%E6%A8%A1%E5%9D%97/CPU%E8%AE%BE%E8%AE%A1%E8%8D%89%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="CPU设计草图"></p><p>这个便是我们大致的设计CPU设计思路，从取址、译码到执行，返回，我们可以根据这个来进行迭代设计。</p><h1 id="第二幕：配置"><a href="#第二幕：配置" class="headerlink" title="第二幕：配置"></a>第二幕：配置</h1><p>根据上边的分析，我们可以初步得出CPU设计至少包含以下组件：</p><blockquote><p>指令内存(MemInst)<br>PC寄存器(PCReg)<br>通用寄存器堆(Register)<br>数据内存(MemData)<br>指令译码器(Decoder)<br>运算单元(ALU)<br>控制单元(Controller)</p></blockquote><p>在设计过程中我们一定要遵循模块化思维，如果把一个CPU全塞到一个文件中，简直是灾难！不管是编写、测试还是调试，都令人头大！</p><p>由于我们在设计的时候便已经划分出诸多模块，因此我们可以分别实现为一个Chisel的Module，然后用一个顶层的Module来将它们连接起来。</p><h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h2><p>在使用chisel正式编写文件之前，我们需要去对他进行一个环境配置，那么scala、chisel、chiseltest之间的版本该如何兼容呢？大家可以参考这个来配置<a href="https://blog.csdn.net/qq_42622433/article/details/136508491">【博客】IC设计：Scala、Chisel、Chiseltest版本兼容信息</a></p><p>关于具体的<code>build.sbt</code>的配置，大家可以直接在github中下载模板，网站链接在此<a href="https://github.com/chipsalliance/chisel-template">Chisel-Template</a></p><p>如果大家还没有进行chisel的安装，可以查看我写的这个博客<a href="">从零开始安装Chisel</a></p><h2 id="2-全局配置"><a href="#2-全局配置" class="headerlink" title="2. 全局配置"></a>2. 全局配置</h2><p>在安装好预备的配置文件之后，我们可以再使用全局配置文件来对我们整个项目进行统一管理。那么为什么要这样做呢？现在我们实现的是32位处理器，那如果我们直接使用32的话，在将来修改的时候，会修改非常多的地方，扩展性变成了一个老大难的问题。而如果有全局配置文件，那我们可以在里边直接用一个对象来存放这些数字，需要修改的时候，直接在这个配置文件里边修改即可。</p><p>包括内存初始化的地址、各种参数等等，都可以放在配置文件中。</p><p>我们可以在<code>src/main/scala/config/</code>文件夹中创建一个<code>Configs.scala</code>文件，内容暂时如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> config<br><br><span class="hljs-keyword">import</span> chisel3._<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Configs</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">ADDR_WIDTH</span> = <span class="hljs-number">32</span>     <span class="hljs-comment">// 地址位宽</span><br>    <span class="hljs-keyword">val</span> <span class="hljs-type">ADDR_BYTE_WIDTH</span> = <span class="hljs-type">ADDR_WIDTH</span> / <span class="hljs-number">8</span>    <span class="hljs-comment">// 地址字节位宽</span><br>    <span class="hljs-keyword">val</span> <span class="hljs-type">DATA_WIDTH</span> = <span class="hljs-number">32</span>     <span class="hljs-comment">// 数据位宽</span><br>    <span class="hljs-keyword">val</span> <span class="hljs-type">DATA_WIDTH_H</span> = <span class="hljs-number">16</span>   <span class="hljs-comment">// 半字数据位宽</span><br>    <span class="hljs-keyword">val</span> <span class="hljs-type">DATA_WIDTH_B</span> = <span class="hljs-number">8</span>    <span class="hljs-comment">// 字节数据位宽</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在其他文件使用configs的时候，首先导入包<code>import config.Configs._</code>，这样便可以导入所有的参数。后续如果需要添加新的参数，直接在这个配置文件中添加即可。</p><h1 id="第三幕：PC模块"><a href="#第三幕：PC模块" class="headerlink" title="第三幕：PC模块"></a>第三幕：PC模块</h1><p>在设计PC之前，我们首先需要思考一下PC究竟是干嘛的，它的功能都有哪些？</p><p>首先我们需要思考它的功能：</p><blockquote><ol><li><strong>32位的指令地址输出</strong>：为指令内存提供地址来获取指令</li><li><strong>自增</strong>：每个时钟周期，PC寄存器中的指令都会自增4，来获取下一个地址</li><li><strong>判断跳转</strong>：如果当前指令为跳转指令，会收到<code>Controller</code>信号<code>ctrlJump</code>，接受计算结果作为下一个地址</li><li><strong>判断分支</strong>：如果当前指令为分支指令，会收到<code>Controller</code>信号<code>ctrlBranch</code>，以及控制单元的分支结果，如果成功就将计算结果作为下一个地址。</li><li><strong>初始化</strong>：寄存器初始化时，输出的指令地址为0</li></ol></blockquote><p>那么PCReg模块(src&#x2F;main&#x2F;scala&#x2F;rv32isc&#x2F;PCReg.scala)：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> rv32isc<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><br><span class="hljs-keyword">import</span> config.<span class="hljs-type">Configs</span>._ <br><br><span class="hljs-comment">// PCReg的接口模块</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCRegIO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> addrOut = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-type">ADDR_WIDTH</span>.<span class="hljs-type">W</span>))        <span class="hljs-comment">// 地址输出</span><br>    <span class="hljs-keyword">val</span> ctrlJump = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())                    <span class="hljs-comment">// 是否为跳转指令</span><br>    <span class="hljs-keyword">val</span> ctrlBranch = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())                  <span class="hljs-comment">// 是否为分支指令</span><br>    <span class="hljs-keyword">val</span> resultBranch = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())                <span class="hljs-comment">// 分支结果是否预测成功</span><br>    <span class="hljs-keyword">val</span> addrTarget = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-type">ADDR_WIDTH</span>.<span class="hljs-type">W</span>))      <span class="hljs-comment">// 跳转分支的目标地址</span><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCReg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">PCRegIO</span>)                                <span class="hljs-comment">// PCReg的接口</span><br>    <span class="hljs-keyword">val</span> regPC = <span class="hljs-type">RegInit</span>(<span class="hljs-type">UInt</span>(<span class="hljs-type">ADDR_WIDTH</span>.<span class="hljs-type">W</span>), <span class="hljs-type">START_ADDR</span>.<span class="hljs-type">U</span>)   <span class="hljs-comment">// PC寄存器，初始化时重置为START_ADDR</span><br><br>    when(io.ctrlJump || (io.ctrlBranch &amp;&amp; io.resultBranch)) &#123;<br>        regPC := io.addrTarget<br>    &#125;.otherwise &#123;<br>        regPC := regPC + <span class="hljs-type">ADDR_BYTE_WIDTH</span>.<span class="hljs-type">U</span><br>    &#125;<br>    io.addrOut := regPC <span class="hljs-comment">// 每个时钟周期输出当前PC寄存器内的地址</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在这里用到了一个常量<code>START_ADDR</code>用来表示起始执行地址，应该在Configs对象中包含：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> <span class="hljs-type">START_ADDR</span>: <span class="hljs-type">Long</span> = <span class="hljs-number">0x0000</span>_0000 <span class="hljs-comment">// 起始执行地址</span><br></code></pre></td></tr></table></figure><p>对于上边的Module，我们使用了<code>when...otherwise</code>这个关键词，但是我们同样可以使用<code>Mux</code>来进行优化：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCReg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">PCRegIO</span>)<br>    <span class="hljs-keyword">val</span> regPC = <span class="hljs-type">RegInit</span>(<span class="hljs-type">START_ADDR</span>.<span class="hljs-type">U</span>(<span class="hljs-type">ADDR_WIDTH</span>.<span class="hljs-type">W</span>)) <span class="hljs-comment">// 初始化PC寄存器为START_ADDR</span><br><br>    <span class="hljs-comment">// 当ctrlJump为true或者ctrlBranch为true且resultBranch为true时, PC寄存器的值为addrTarget, 否则为PC寄存器的值加上ADDR_BYTE_WIDTH</span><br>    regPC := <span class="hljs-type">Mux</span>(io.ctrlJump || (io.ctrlBranch &amp;&amp; io.resultBranch), io.addrTarget, regPC + <span class="hljs-type">ADDR_BYTE_WIDTH</span>.<span class="hljs-type">U</span>)<br>    <br>    io.addrOut := regPC <span class="hljs-comment">// 每个时钟周期输出当前PC寄存器内的地址</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们现在已经有了一个最基本的PC框架。</p><p><strong>是这样吗？</strong></p><p>假设我们现在有一个超过32位的地址该怎么办？或者当我们的组合信号无效了怎么办？<br>因此我们还需要对我们的代码进行一些健壮性的加强，俗称：打补丁！</p><p>下边是修改之后的PC代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> rv32isc<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chisel3.util._<br><br><span class="hljs-keyword">import</span> config.<span class="hljs-type">Configs</span>._ <br><br><span class="hljs-comment">// PCReg的接口模块</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCRegIO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> addrOut = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-type">ADDR_WIDTH</span>.<span class="hljs-type">W</span>))        <span class="hljs-comment">// 地址输出</span><br>    <span class="hljs-keyword">val</span> ctrlJump = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())                    <span class="hljs-comment">// 是否为跳转指令</span><br>    <span class="hljs-keyword">val</span> ctrlBranch = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())                  <span class="hljs-comment">// 是否为分支指令</span><br>    <span class="hljs-keyword">val</span> resultBranch = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())                <span class="hljs-comment">// 分支结果是否预测成功</span><br>    <span class="hljs-keyword">val</span> addrTarget = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-type">ADDR_WIDTH</span>.<span class="hljs-type">W</span>))      <span class="hljs-comment">// 跳转分支的目标地址</span><br>    <span class="hljs-keyword">val</span> resetSignal = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())                 <span class="hljs-comment">// 复位信号</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCReg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">PCRegIO</span>)<br>    <span class="hljs-keyword">val</span> regPC = <span class="hljs-type">RegInit</span>(<span class="hljs-type">START_ADDR</span>.<span class="hljs-type">U</span>(<span class="hljs-type">ADDR_WIDTH</span>.<span class="hljs-type">W</span>)) <span class="hljs-comment">// 初始化PC寄存器为START_ADDR</span><br><br>    <span class="hljs-comment">// 地址范围限制</span><br>    <span class="hljs-keyword">val</span> maxAddr = <span class="hljs-string">&quot;hFFFFFFFF&quot;</span>.<span class="hljs-type">U</span>(<span class="hljs-type">ADDR_WIDTH</span>.<span class="hljs-type">W</span>)  <span class="hljs-comment">// 最大地址，32位最大值</span><br>    <span class="hljs-keyword">val</span> nextPC = <span class="hljs-type">Mux</span>(io.ctrlJump || (io.ctrlBranch &amp;&amp; io.resultBranch), io.addrTarget, regPC + <span class="hljs-type">ADDR_BYTE_WIDTH</span>.<span class="hljs-type">U</span>)<br><br>    <span class="hljs-comment">// 当复位信号为true时，将PC寄存器复位为START_ADDR，否则检查边界，保证PC寄存器值有效</span><br>    regPC := <span class="hljs-type">Mux</span>(io.resetSignal, <span class="hljs-type">START_ADDR</span>.<span class="hljs-type">U</span>, <span class="hljs-type">Mux</span>(nextPC &lt;= maxAddr, nextPC, <span class="hljs-type">START_ADDR</span>.<span class="hljs-type">U</span>))<br><br>    <span class="hljs-comment">// 地址输出</span><br>    io.addrOut := regPC<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们增加了边界条件，增加了对<code>nextPC</code>的边界检查，确保更新的PC值在最大地址范围之内，如果超出范围，则将PC重置为初始地址（这个不一定正确，但是我们可以先这样设计）。<br>同时我们增加了一个复位信号<code>resetSignal</code>，当复位信号为真的时候，PC寄存器直接重置为<code>START_ADDR</code>。<br>之后我们增加无效信号处理，通过检查边界和复位逻辑来处理无效信号的情况，如果计算值超过PC范围，就认为这是一个无效信号，重置PC。</p><p>在创建好<code>PCReg</code>模块之后，我们便可以用一些测试来验证自己写的代码是否正确：<br>代码可以放在<code>src/test/scala/rv32isc/PCRegTest.scala/</code>:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> rv32isc<br><br><span class="hljs-keyword">import</span> chisel3._<br><span class="hljs-keyword">import</span> chiseltest._<br><span class="hljs-keyword">import</span> chisel3.util._<br><span class="hljs-keyword">import</span> org.scalatest.flatspec.<span class="hljs-type">AnyFlatSpec</span><br><br><span class="hljs-keyword">import</span> config.<span class="hljs-type">Configs</span>._<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PCRegTestFunc</span> </span>&#123;<br>    <span class="hljs-comment">// 生成十个随机地址用于测试，确保地址在32位范围内</span><br>    <span class="hljs-keyword">val</span> target_list = <span class="hljs-type">Seq</span>.fill(<span class="hljs-number">10</span>)((scala.util.<span class="hljs-type">Random</span>.nextInt() &amp; <span class="hljs-number">0x00ffffffff</span>L).toLong)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testFn</span></span>(dut: <span class="hljs-type">PCReg</span>): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-comment">// 初始化状态测试</span><br>        dut.io.ctrlBranch.poke(<span class="hljs-literal">false</span>.<span class="hljs-type">B</span>)<br>        dut.io.ctrlJump.poke(<span class="hljs-literal">false</span>.<span class="hljs-type">B</span>)<br>        dut.io.resultBranch.poke(<span class="hljs-literal">false</span>.<span class="hljs-type">B</span>)<br>        dut.io.addrTarget.poke(<span class="hljs-type">START_ADDR</span>.<span class="hljs-type">U</span>)<br>        dut.io.addrOut.expect(<span class="hljs-type">START_ADDR</span>.<span class="hljs-type">U</span>)<br>        <br>        <span class="hljs-keyword">var</span> addr: <span class="hljs-type">Long</span> = <span class="hljs-type">START_ADDR</span><br><br>        <span class="hljs-comment">// 测试1：正常自增功能</span><br>        <span class="hljs-keyword">for</span> (target &lt;- target_list) &#123;<br>            dut.io.addrTarget.poke(target.<span class="hljs-type">U</span>)<br>            addr += <span class="hljs-type">ADDR_BYTE_WIDTH</span><br>            dut.clock.step()<br>            dut.io.addrOut.expect(addr.<span class="hljs-type">U</span>)<br>        &#125;<br><br>        <span class="hljs-comment">// 测试2：跳转功能</span><br>        dut.io.ctrlJump.poke(<span class="hljs-literal">true</span>.<span class="hljs-type">B</span>)<br>        <span class="hljs-keyword">for</span> (target &lt;- target_list) &#123;<br>            dut.io.addrTarget.poke(target.<span class="hljs-type">U</span>)<br>            dut.clock.step()<br>            dut.io.addrOut.expect(target.<span class="hljs-type">U</span>)<br>            addr = target<br>        &#125;<br>        dut.io.ctrlJump.poke(<span class="hljs-literal">false</span>.<span class="hljs-type">B</span>)<br><br>        <span class="hljs-comment">// 测试3：分支功能 - 分支不成功</span><br>        dut.io.ctrlBranch.poke(<span class="hljs-literal">true</span>.<span class="hljs-type">B</span>)<br>        <span class="hljs-keyword">for</span> (target &lt;- target_list) &#123;<br>            dut.io.addrTarget.poke(target.<span class="hljs-type">U</span>)<br>            addr += <span class="hljs-type">ADDR_BYTE_WIDTH</span><br>            dut.clock.step()<br>            dut.io.addrOut.expect(addr.<span class="hljs-type">U</span>)<br>        &#125;<br><br>        <span class="hljs-comment">// 测试4：分支功能 - 分支成功</span><br>        dut.io.resultBranch.poke(<span class="hljs-literal">true</span>.<span class="hljs-type">B</span>)<br>        <span class="hljs-keyword">for</span> (target &lt;- target_list) &#123;<br>            dut.io.addrTarget.poke(target.<span class="hljs-type">U</span>)<br>            dut.clock.step()<br>            dut.io.addrOut.expect(target.<span class="hljs-type">U</span>)<br>            addr = target<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCRegTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFlatSpec</span> <span class="hljs-keyword">with</span> <span class="hljs-title">ChiselScalatestTester</span> <span class="hljs-keyword">with</span> <span class="hljs-title">PCRegTestFunc</span> </span>&#123;<br>    <span class="hljs-string">&quot;PCReg&quot;</span> should <span class="hljs-string">&quot;pass all the tests&quot;</span> in &#123;<br>        test(<span class="hljs-keyword">new</span> <span class="hljs-type">PCReg</span>) &#123; dut =&gt;<br>            testFn(dut)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试通过的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[info] PCRegTest:<br>[info] PCReg<br>[info] - should pass all the tests<br>[info] Run completed <span class="hljs-keyword">in</span> 2 seconds, 558 milliseconds.<br>[info] Total number of tests run: 1<br>[info] Suites: completed 1, aborted 0<br>[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0<br>[info] All tests passed.<br>[success] Total time: 5 s, completed 2024年8月19日 下午3:05:40<br></code></pre></td></tr></table></figure><p>感谢大家看到这里，未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>Chisel实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-小说组织架构</title>
    <link href="/2024/08/15/2_1-%E5%B0%8F%E8%AF%B4%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/08/15/2_1-%E5%B0%8F%E8%AF%B4%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="小说推理架构思路"><a href="#小说推理架构思路" class="headerlink" title="小说推理架构思路"></a>小说推理架构思路</h1><p>从7月份开始构思小说，已经构思了一个月，但是还是没有很好的思路，为了防止自己内耗，我决定把自己平时拆书的心得分享给大家！本篇讲的是小说故事线的推理架构以及拆书，如何从各大榜单上找到有用的信息点。</p><h2 id="1-开篇通用模板"><a href="#1-开篇通用模板" class="headerlink" title="1. 开篇通用模板"></a>1. 开篇通用模板</h2><p>网文的开篇小说的通用模板如下：</p><blockquote><ol><li>切入事件（一下子能抓住读者眼球）</li><li>解释事件因果，目的是解释主角身份背景（拉仇恨、博同情、制造氛围），接下来即将面临什么危机</li><li>主角怎么想的，有什么策略（暗示主角与众不同，从而为主角获得金手指理所当然）</li><li>主角不得不去做某一件事情，但是主角一筹莫展或者面临巨大的挑战</li><li>主角获得金手指，问题变得可以解决（向读者暗示主角接下来可以实现脱困或者装逼打脸）</li><li>反派登场施压，主角被打脸或者陷入危机，暗示金手指即将发挥作用</li></ol></blockquote><p>需要注意的是，在开头切入事件的过程中，不要过多的铺设定，而是用配角或者环境来描述出来，而不是用上帝视角直接写出来。</p><p>在断章的过程中，一般来说把故事的高潮刚展开就结束，这样就会有一个很好的钩子的效果。</p><h2 id="2-如何把平淡的日常写的很有趣味性？"><a href="#2-如何把平淡的日常写的很有趣味性？" class="headerlink" title="2. 如何把平淡的日常写的很有趣味性？"></a>2. 如何把平淡的日常写的很有趣味性？</h2><p>在小说中，总是会遇到一些工具章节作为铺垫，那我们该怎么办呢？</p><p>其实就是把故事尽量不要和盘托出，而是慢慢的来展开，给读者一点猜疑，但是又不是完全猜得到，让读者有一种优越感，或者是在文章中加一些小小的冲突（一句话就好）。</p><p>如果说信息差是拉起期待感最简单的方法，那么设计误会就是拉起读者期待感最惯用的套路。</p><p>如何实现让误会解除呢？——情绪价值</p><p>给读者提供极大的情绪价值，明显让读者得到误会解除的满足感，吃瓜感。甚至在产生误会之前就要有一种产生不确定的情绪，之后再铺垫被误会，最终最终解除误会。</p><p>例如：一方付出了代价，但是被另一方误会，并且做出了伤害或者忽视对方的行为。</p><ol><li>升级矛盾。</li><li>情感共鸣</li><li>给于希望（工具人给出解决问题的办法）</li><li>希望受阻（由于主观&#x2F;客观原因无法达成希望）</li></ol><p>以上是如何让读者产生强烈的期待感，那么如何把这份情绪再最终落地呢？</p><p>可以告诉读者某一件事情很难完成，但是又提供一种暗示，那么当未来这个事情发生的时候，读者就会有一种预料之感，但是又会觉得理所当然。</p><p>例如：</p><blockquote><p>小红是一个高冷校花，张三是一个舔狗。（矛盾）<br>张三付出了很多，校花都没有理会。（升级矛盾）<br>张三好不容易修好了校花的自行车，但是校花却以为张三偷偷摸摸给她自行车搞破坏（情感共鸣）<br>张三没来得及开口解释，被李四拉走办别的事情，校花回家路上听到闺蜜说是张三修好的（给于希望）<br>校花太傲娇，还是不想对张三说一声谢谢（希望受阻，人设原因）<br>张三受伤，校花恰巧看到，关心张三（误会解除，但是又没完全解除）</p></blockquote><p>以上是我临时想出来的一个故事，虽然写的不是很好，但是基本能够写出了对于情绪的拉扯。</p><p>我们可以套用这种<code>误会</code>的方式，来让读者产生一种期待感。</p><p><img src="/2024/08/15/2_1-%E5%B0%8F%E8%AF%B4%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%8B%89%E6%89%AF%E6%9C%9F%E5%BE%85%E6%84%9F.png" srcset="/img/loading.gif" lazyload alt="拉扯期待感"></p><p>这个图是B站一个很有名的UP主拆解的一篇小说，我们可以看到作者对于情绪的拉扯甚至不只有一次，而是交错复杂，这样子很能够让读者的心一蹦一蹦的。</p><h2 id="3-如何设计出一个故事"><a href="#3-如何设计出一个故事" class="headerlink" title="3. 如何设计出一个故事"></a>3. 如何设计出一个故事</h2><p>当我们扫完榜之后，我们自然的会想到构建出一个属于我们自己的故事，但我们要不就是写的和之前看的极为雷同，要不就是写出来的故事平平无奇，那如何创建一个属于我们自己的故事呢？</p><p>今天我们主要分享两个思路，来解决新人构建大纲的难题。（后续我也会在网站上持续更新，当然，我也是新人，一本书都没写出来的那种）</p><h3 id="1-没经验，怎么写？"><a href="#1-没经验，怎么写？" class="headerlink" title="1. 没经验，怎么写？"></a>1. 没经验，怎么写？</h3><p>很多视频上来就说，本视频针对有第一本完本经验的作者，那些技巧对他们来说当然好，但是我们这种一本书都没写过的该怎么办？</p><p>对于大部分新人来说，连1万字都写不出来才是常态。</p><p>那我们如何从零构建一个大纲呢？</p><ol><li><p>【计划-意外】主角实施计划，遭遇意外。</p><blockquote><p>主角有一个目标A，开始实施计划1，并且取得了一定的成果，但是意外1计划失败，主角有了新的目标B，实施计划2：先去B，人物开始成长(小高潮)，此时意外2发生，主角找到最终路径，计划3，大结局。</p></blockquote></li><li><p>【大高潮逆推法】先把最高潮的部分想出来，最爽的一幕，所有的人物都会参与进去。</p><blockquote><p>开始解构矛盾与冲突，其中的逻辑关系。开始逆推情节到小高潮，小高潮没办法解决核心冲突，并且最好是引出下一幕的矛盾，在当前是次要矛盾，下一幕就变成主要矛盾。一直逆推到最初主角和敌人的冲突场景。（需要存稿3-6万字）</p></blockquote></li><li><p>上边两个方法，先用2再用1，一般来说效果会更好一些。</p></li></ol><p>要有心理预期，一开始写的和我最终写的差距很大。</p><h2 id="附录I-参考文献"><a href="#附录I-参考文献" class="headerlink" title="附录I 参考文献"></a>附录I 参考文献</h2><ol><li><a href="https://www.bilibili.com/video/BV1kK4y1e7fM/?spm_id_from=333.999.0.0&vd_source=98101c1de7471be746ee7086e136f38f">B站UP主宝剑侍从视频：网文新人构建剧情难？给你两条思路和诀窍</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>小说技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说推理思路</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
